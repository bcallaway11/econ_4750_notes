[
  {
    "objectID": "01-statistical_programming.html",
    "href": "01-statistical_programming.html",
    "title": "2  Statistical Programming",
    "section": "",
    "text": "2.1 Setting up R\nThis section covers how to set up R and RStudio and then what RStudio will look like when you open it up.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#setting-up-r",
    "href": "01-statistical_programming.html#setting-up-r",
    "title": "2  Statistical Programming",
    "section": "",
    "text": "2.1.1 What is R?\nRelated Reading: IDS 1.1\nR is a statistical programming language. This is important for two reasons\n\nIt looks like a “real” programming language. In my view, this is a big advantage. And many of the programming skills that we will learn in this class will be transferable. What I mean is that, if you one day want to switch to writing code in Stata or Python, I think the switch should be not-too-painful because learning new “syntax” (things like where to put the semi-colons) is usually relatively easy compared to the “way of thinking” about how to write code. Some other statistical programming languages are more “canned” than R. In some sense, this makes them easier to learn, but this also comes with the drawback that whatever skills that you learn are quite specific to that one language.\nEven though R is a real programming language, it is geared towards statistics. Compared to say, Matlab, a lot of common statistical procedures (e.g., running a regression) will be quite easy for you.\n\nR is very popular among statisticians, computer scientists, economists.\nIt is easy to share code across platforms: Linux, Windows, Mac. Besides that, it is easy to write and contribute extensions. I have 10+ R packages that you can easily download and immediately use.\nThere is a large community, and lots of available, helpful resources.\n\nFirst place to look if you don’t know how to do something: DuckDuckGo (or…err…Google)!\nStackOverflow\n\n\n\n2.1.2 Downloading R\nWe will use R (https://www.r-project.org/) to analyze data. R is freely available and available across platforms. You should go ahead and download R for your personal computer as soon as possible — this should be relatively straightforward. It is also available at most computer labs on campus.\n\n\n2.1.3 RStudio\nBase R comes with a lightweight development environment (i.e., a place to write and execute code), but most folks prefer RStudio as it has more features. You can download it here: https://www.rstudio.com/products/rstudio/download/#download; choose the free version based on your operating system (Linux, Windows, Mac, etc.).\n\n\n2.1.4 RStudio Development Environment\nRelated Reading: IDS 1.4\nWhen you first open Rstudio, it will look something like this\n\nTypically, we will write scripts, basically just as a way to save the code that we have written. Go to File -&gt; New File -&gt; R Script. This will open up a new pane, and your screen should look something like this\n\nLet’s look around here. The top left pane is called the “Source Pane”. It is where you can write an R script. Try typing\n\n1+1\n\nin that pane. This is a very simple R program. Now, type Ctrl+s to save the script. This will likely prompt you to provide a name for the script. You can call it first_script.R or something like that. The only thing that really matters is that the file name ends in “.R” (although you should at least give the file a reasonably descriptive name).\nNow let’s move to the bottom left pane. This is called the “Console Pane”. It is where the actual computations happen in R (Notice that, although we have already saved our first script, we haven’t actually run any code). Beside the blue arrow in that pane, try typing\n\n2+2\n\nand then press ENTER. This time you should actually see the answer.\nNow, let’s go back to the Source pane. Often, it is convenient to run R programs line by line (mainly in order for it to be easy for you to digest the results). You can do this by pressing Ctrl+ENTER on any line in your script for it to run next. Try this on the first line of your script file where we previously typed 1+1. This code should now run, and you should be able to see the result down in the bottom left Console pane.\nWe will ignore the two panes on the right for now and come back to them once we get a little more experience programming in R.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#installing-r-packages",
    "href": "01-statistical_programming.html#installing-r-packages",
    "title": "2  Statistical Programming",
    "section": "2.2 Installing R Packages",
    "text": "2.2 Installing R Packages\nRelated Reading: IDS 1.5\nWhen you download R, you get “base” R. Base R contains “basic” functions that are commonly used by most R users. To give some examples, base R gives you the ability add, subtract, divide, or multiply numbers. Base R gives you the ability to calculate the mean (the function is called mean) or standard deviation (the function is called sd) of a vector of numbers.\nBase R is quite powerful and probably the majority of code you will write in R will only involve Base R.\nThat being said, there are many cases where it is useful to expand the base functionality of R. This is done through packages. Packages expand the functionality of R. R is open source so these packages are contributed by users.\nIt also typically wouldn’t make sense for someone to install all available R packages. For example, a geographer might want to install a much different set of packages relative to an economist. Therefore, we will typically install only the additional functionality that we specifically want.\n\nIn this example, we’ll install the dslabs package (which is from the IDS book) and the lubridate package (which is a package for working with dates in R).\n\n# install dslabs package\ninstall.packages(\"dslabs\")\n\n# install lubridate package\ninstall.packages(\"lubridate\")\n\n\nInstalling a package is only the first step to using a package. You can think of installing a package like downloading a package. To actually use a package, you need to load it into memory (i.e., “attach” it) or at least be clear about the package where a function that you are trying to call comes from.\n\nDates can be tricky to work with in R (and in programming languages generally). For example, they are not exactly numbers, but they also have more structure than just a character string. The lubridate package contains functions for converting numbers/strings into dates.\n\nbday &lt;- \"07-15-1985\"\nclass(bday) # R doesn't know this is actually a date yet\n\n[1] \"character\"\n\n# load the package\nlibrary(lubridate)\n# mdy stands for \"month, day, year\"\n# if date were in different format, could use ymd, etc.\ndate_bday &lt;- mdy(bday)\ndate_bday\n\n[1] \"1985-07-15\"\n\n# now R knows this is a date\nclass(date_bday)\n\n[1] \"Date\"\n\n\nAnother (and perhaps better) way to call a function from a package is to use the :: syntax. In this case, you do not need the call to library from above. Instead, you can try\n\nlubridate::mdy(bday)\n\n[1] \"1985-07-15\"\n\n\nThis does exactly the same thing as the code before. What is somewhat better about this code is that it is easier to tell that the mdy function came from the lubridate package.\n\n\n2.2.1 A list of useful R packages\n\nAER — package containing data from Applied Econometrics with R\nwooldridge — package containing data from Wooldridge’s text book\nggplot2 — package to produce sophisticated looking plots\ndplyr — package containing tools to manipulate data\nhaven — package for loading different types of data files\nplm — package for working with panel data\nfixest — another package for working with panel data\nivreg — package for IV regressions, diagnostics, etc.\nestimatr — package that runs regressions but with standard errors that economists often like more than the default options in R\nmodelsummary — package for producing nice output of more than one regression and summary statistics\n\nAs of this writing, there are currently 18,004 R packages available on CRAN (R’s main repository for contributed packages).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#r-basics",
    "href": "01-statistical_programming.html#r-basics",
    "title": "2  Statistical Programming",
    "section": "2.3 R Basics",
    "text": "2.3 R Basics\nRelated Reading: IDS 2.1\nIn this section, we’ll start to work towards writing useful R code.\n\n2.3.1 Objects\nRelated Reading: IDS 2.2\nThe very first step to writing code that can actually do something is to able to store things. In R, we store things in objects (perhaps sometimes I will also use the word variables).\nEarlier, we used R to calculate \\(1+1\\). Let’s go back to the Source pane (top left pane in RStudio) and type\n\nanswer &lt;- 1 + 1\n\nPress Ctrl+ENTER on this line to run it. You should see the same line down in the Console now.\nLet’s think carefully about what is happening here\n\nanswer is the name of the variable (or object) that we are creating here.\nthe &lt;- is the assignment operator. It means that we should assign whatever is on the right hand side of it to the variable that is on the left hand side of it\n1+1 just computes \\(1+1\\) as we did earlier. Soon we will put more complicated expressions here.\n\nYou can think about the above code as computing \\(1+1\\) and then saving it in the variable answer.\n\nSide Comment: The assignment operator, &lt;-, is a “less than sign” followed by a “hyphen”. It’s often convenient though to use the keyboard shortcut Alt+- (i.e., hold down Alt and press the hypen key) to insert it. You can also use an = for assignment, but this is less commonly done in R.\n\n\nPractice: Try creating variable called five_squared that is equal to \\(5 \\times 5\\) (multiplication in R is done using the * symbol).\n\nThere are a number of reasons why you might like to create an object in R. Perhaps the main one is so that you can reuse it. Let’s try multiplying answer by \\(3\\).\n\nanswer*3\n\n[1] 6\n\n\nIf you wanted, you could also save this as its own variable too.\n\n\n2.3.2 Workspace\nRelated Reading: IDS 2.2\nBefore we move on, I just want to show you what my workspace looks like now.\n\nAs we talked about above, you can see the code in my script in the Source pane in the top left. You can also see the code that I actually ran in the Console pane on the bottom left.\nNow, take a look at the top right pane. You will see under the Environment tab that answer shows up there with a value of 2. The Environment tab keeps track of all the variables that you have created in your current session. A couple of other things that might be useful to point out there.\n\nLater on in the class, we will often import data to work with. The “Import Dataset” button that is located in this top right pane is often useful for this.\nOccasionally, you might get into the case where you have saved a bunch of variables and it would be helpful to “start over”. The broom in this pane will “clean” your workspace (this just means delete everything).\n\n\n\n2.3.3 Importing Data\nTo work with actual data in R, we will need to import it. I mentioned the “Import Data” button above, but let me mention a few other possibilities here, including how to import data by writing code.\nOn the course website, I posted three files firm.data.csv, firm_data.RData, and firm_data.dta. All three of these contain exactly the same small, fictitious dataset, but are saved in different formats.\nProbably the easiest way to import data in R is through the Files pane on the bottom right. In particular, suppose that you saved firm_data.csv in your “Downloads” folder. Try clicking the “…” (which, in the screenshot of my workspace above, is right beside the folder that I am in which is called “Detailed Course Notes”), then select your Downloads folder. This will switch the content of the Files pane to show the files in your Downloads folder. Now click firm_data.csv. This will open a menu to import the data. R is quite good at recognizing different types of data files and importing them, so this same procedure will work for firm_data.RData and firm_data.dta even though they are different types of files.\nNext, let’s discuss how to import data by writing computer code (by the way, this is actually what is happening behind the scenes when you import data through the user interface as described above). “csv” stands for “Comma Separated Values”. This is basically a plain text file (e.g., try opening it in Notepad or Text Editor) where the columns are separated by commas and the rows are separated by being on different lines. Most any computer program can read this type of file; that is, you could easily import this file into, say, R, Excel, or Stata. You can import a .csv file using R code by\n\nfirm_data &lt;- read.csv(\"firm_data.csv\")\n\nAn RData file is the native format for saving data in R. You can import an RData file using the following command:\n\nfirm_data &lt;- load(\"firm_data.RData\")\n\nSimilarly, a dta file the native format for saving data in Stata. You can import a dta file using the following command:\n\nlibrary(haven) # external package for reading dta file\nfirm_data &lt;- read_dta(\"firm_data.dta\")\n\nIn all three cases above, what we have done is to create a new data.frame (a data.frame is a type of object that we’ll talk about in detail later on in this chapter) called firm_data that contains the data that we were trying to load.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#functions-in-r",
    "href": "01-statistical_programming.html#functions-in-r",
    "title": "2  Statistical Programming",
    "section": "2.4 Functions in R",
    "text": "2.4 Functions in R\nRelated Reading: IDS 2.2\nR has a large number of helpful, built-in functions. Let’s start with a pretty representative example: computing logarithms. This can be done using the R function log.\n\nlog(5)\n\n[1] 1.609438\n\n\nYou can tell this is a function because of the parentheses. The 5 inside of the parentheses is called the argument of the function. As practice, try computing the \\(\\log\\) of 7.\n\nSide Comment: As a reminder, the logarithm of some number, let’s call it \\(b\\), is is the value of \\(a\\) that solves \\(\\textrm{base}^a = b\\).\n\nThe default base in R is \\(e \\approx 2.718\\), so that log(5) actually computes what you might be more used to calling the “natural logarithm”. You can change the default value of the base by adding an extra argument to the function.\n\nlog(5, base=10)\n\n[1] 0.69897\n\n\nIn order to learn about what arguments are available (and what they mean), you can access the help files for a particular function by running either\n\nhelp(log)\n?log\n\nand, of course, substituting the name of whatever function you want to learn about in place of log.\nIn RStudio, it can also be helpful to press Tab and RStudio will provide possible completions to the function you are typing as well as what arguments can be provided to that function.\n\nPractice: R has a function for computing absolute value (you’ll have to find the name of it on your own). Try computing the absolute value of \\(5\\) and \\(-5\\). Try creating a variable called negative_three that is equal to \\(-3\\); then, try to compute the absolute value of negative_three.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#data-types",
    "href": "01-statistical_programming.html#data-types",
    "title": "2  Statistical Programming",
    "section": "2.5 Data types",
    "text": "2.5 Data types\nRelated Reading: IDS 2.4\n\n2.5.1 Numeric Vectors\nThe most basic data type in R is the vector. In fact, above when we created variables that were just a single number, they are actually stored as a numeric vector.\nTo more explicitly create a vector, you can use the c function in R. For example, let’s create a vector called five that contains the numbers 1 through 5.\n\n  five &lt;- c(1,2,3,4,5)\n\nWe can print the contents of the vector five just by typing its name\n\nfive\n\n[1] 1 2 3 4 5\n\n\nAnother common operation on vectors is to get a particular element of a vector. Let me give an example\n\nfive[3]\n\n[1] 3\n\n\nThis code takes the vector five and returns the third element in the vector. Notice that the above line contains braces, [ and ] rather than parentheses.\nIf you want several different elements from a vector, you can do the following\n\nfive[c(1,4)]\n\n[1] 1 4\n\n\nThis code takes the vector five and returns the first and fourth element in the vector.\nOne more useful function for vectors is the function length. This tells you the number of elements in vector. For example,\n\nlength(five)\n\n[1] 5\n\n\nwhich means that there are five total elements in the vector five.\n\n\n2.5.2 Vector arithmetic\nRelated Reading: IDS 2.11\nThe main operations on numeric vectors are +, -, *, / which correspond to addition, subtraction, multiplication, and division. Often, we would like to carry out these operations on vectors.\nThere are two main cases. The first case is when you try to add a single number (i.e., a scalar) to all the elements in a vector. In this setup, the operation will happen element-wise which means the same number will be added to all numbers in the vector. This will be clear with some examples.\n\nfive &lt;- c(1,2,3,4,5)\n\n# adds one to each element in vector\nfive + 1\n\n[1] 2 3 4 5 6\n\n# also adds one to each element in vector\n1 + five\n\n[1] 2 3 4 5 6\n\n\nSimilar things will happen with the other mathematical operations above. Here are some more examples:\n\nfive * 3\n\n[1]  3  6  9 12 15\n\nfive - 3\n\n[1] -2 -1  0  1  2\n\nfive / 3\n\n[1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667\n\n\nThe other interesting case is what happens when you try to apply any of the same mathematical operators to two different vectors.\n\n# just some random numbers\nvec2 &lt;- c(8,-3,4,1,7)\n\nfive + vec2\n\n[1]  9 -1  7  5 12\n\nfive - vec2\n\n[1] -7  5 -1  3 -2\n\nfive * vec2\n\n[1]  8 -6 12  4 35\n\nfive / vec2\n\n[1]  0.1250000 -0.6666667  0.7500000  4.0000000  0.7142857\n\n\nYou can immediately see what happens here. For example, for five + vec2, the first element of five is added to the first element of vec2, the second element of five is added to the second element of vec2 and so on. Similar things happen for each of the other mathematical operations too.\nThere’s one other case that might be interesting to consider too. What happens if you try to apply these mathematical operations to two vectors of different lengths? Let’s find out\n\nvec3 &lt;- c(2,6)\nfive + vec3\n\nWarning in five + vec3: longer object length is not a multiple of shorter\nobject length\n\n\n[1]  3  8  5 10  7\n\n\nYou’ll notice that this computes something but it also issues a warning. What happens here is that the result is equal to the first element of five plus the first element of vec3, the second of five plus the second element of vec3, the third element of five plus the first element of vec3, the fourth element of five plus the second element of vec3, and the fifth element of five plus the first element of vec3. What’s happening here is that, since vec3 contains fewere elements that five, the elements of vec3 are getting recycled. In my experience, this warning often indicates a coding mistake. There are many cases where I want to add the same number to all elements in a vector, and many other cases where I want to add two vectors that have the same length, but I cannot think of any cases where I would want to add two vectors the way that is being carried out here.\nThe same sort of things will happen with subtraction, multiplication, and division (feel free to try it out).\n\n\n2.5.3 More helpful functions in R\nThis is definitely an incomplete list, but I’ll point you here to some more functions in R that are often helpful along with quick examples of them.\n\nseq function — creates a “sequence” of numbers\n\nseq(2,7)\n\n[1] 2 3 4 5 6 7\n\n\nsum function — computes the sum of a vector of numbers\n\nsum(c(1,5,8))\n\n[1] 14\n\n\nsort, order, and rev functions — functions for understanding the order or changing the order of a vector\n\nsort(c(3,1,5))\n\n[1] 1 3 5\n\norder(c(3,1,5))\n\n[1] 2 1 3\n\nrev(c(3,1,5))\n\n[1] 5 1 3\n\n\n%% — modulo function (i.e., returns the remainder from dividing one number by another)\n\n8 %% 3\n\n[1] 2\n\n1 %% 3\n\n[1] 1\n\n\n\n\nPractice: The function seq contains an optional argument length.out. Try running the following code and seeing if you can figure out what length.out does.\n\nseq(1,10,length.out=5)\nseq(1,10,length.out=10)\nseq(1.10,length.out=20)\n\n\n\n\n2.5.4 Other types of vectors\nThere are other types of vectors in R too. Probably the main two other types of vectors are character vectors and logical vectors. We’ll talk about character vectors here and defer logical vectors until later. Character vectors are often referred to as strings.\nWe can create a character vector as follows\n\nstring1 &lt;- \"econometrics\"\nstring2 &lt;- \"class\"\nstring1\n\n[1] \"econometrics\"\n\n\nThe above code creates two character vectors and then prints the first one.\n\nSide Comment c stands for “concatenate”. Concatenate is a computer science word that means to combine two vectors. Probably the most well known version of this is “string concatenation” that combines two vectors of characters. Here is an example of string concatenation.\n\nc(string1, string2)\n\n[1] \"econometrics\" \"class\"       \n\n\nSometimes string concatenation means to put two (or more strings) into the same string. This can be done using the paste command in R.\n\npaste(string1, string2)\n\n[1] \"econometrics class\"\n\n\nNotice that paste puts in a space between string1 and string2. For practice, see if you can find an argument to the paste function that allows you to remove the space between the two strings.\n\n\n\n2.5.5 Data Frames\nAnother very important type of object in R is the data frame. I think it is helpful to think of a data frame as being very similar to an Excel spreadsheet — sort of like a matrix or a two-dimensional array. Each row typically corresponds to a particular observation, and each column typically provides the value of a particular variable for that observation.\nJust to give a simple example, suppose that we had firm-level data about the name of the firm, what industry a firm was in, what county they were located in, and their number of employees. I created a data frame like this (it is totally made up, BTW) and show it to you next\n\nfirm_data\n\n\n\n\nname\nindustry\ncounty\nemployees\n\n\n\n\nABC Manufacturing\nManufacturing\nClarke\n531\n\n\nMartin’s Muffins\nFood Services\nOconee\n6\n\n\nDown Home Appliances\nManufacturing\nClarke\n15\n\n\nClassic City Widgets\nManufacturing\nClarke\n211\n\n\nWatkinsville Diner\nFood Services\nOconee\n25\n\n\n\n\nSide Comment: If you are following along on R, I created this data frame using the following code\n\nfirm_data &lt;- data.frame(name=c(\"ABC Manufacturing\", \"Martin\\'s Muffins\", \"Down Home Appliances\", \"Classic City Widgets\", \"Watkinsville Diner\"),\n                        industry=c(\"Manufacturing\", \"Food Services\", \"Manufacturing\", \"Manufacturing\", \"Food Services\"),\n                        county=c(\"Clarke\", \"Oconee\", \"Clarke\", \"Clarke\", \"Oconee\"),\n                        employees=c(531, 6, 15, 211, 25))\n\nThis is also the same data that we loaded earlier in Section 2.3.\n\nOften, we’ll like to access a particular column in a data frame. For example, you might want to calculate the average number of employees across all the firms in our data.\nTypically, the easiest way to do this, is to use the accessor symbol, which is $ in R. This will make more sense with an example:\n\nfirm_data$employees\n\n[1] 531   6  15 211  25\n\n\nfirm_data$employees just provides the column called “employees” in the data frame called “firm_data”. You can also notice that firm_data$employees is just a numeric vector. This means that you can apply any of the functions that we have been covering on it\n\nmean(firm_data$employees)\n\n[1] 157.6\n\nlog(firm_data$employees)\n\n[1] 6.274762 1.791759 2.708050 5.351858 3.218876\n\n\n\nSide Comment: Notice that the function mean and log behave differently. mean calculates the average over all the elements in the vector firm_data$employees and therefore returns a single number. log calculates the logarithm of each element in the vector firm_data$employees and therefore returns a numeric vector with five elements.\n\n\nSide Comment:\nThe $ is not the only way to access the elements in a data frame. You can also access them by their position. For example, if you want whatever is in the third row and second column of the data frame, you can get it by\n\nfirm_data[3,2]\n\n[1] \"Manufacturing\"\n\n\nSometimes it is also convenient to recover a particular row or column by its position in the data frame. Here is an example of recovering the entire fourth row\n\nfirm_data[4,]\n\n                  name      industry county employees\n4 Classic City Widgets Manufacturing Clarke       211\n\n\nNotice that you just leave the “column index” (which is the second one) blank\n\n\nSide Comment: One other thing that sometimes takes some getting used to is that, for programming in general, you have to be very precise. Suppose you were to make a very small typo. R is not going to understand what you mean. See if you can spot the typo in the next line of code.\n\nfirm_data$employes\n\nNULL\n\n\n\nA few more useful functions for working with data frames are:\n\nnrow and ncol — returns the number of rows or columns in the data frame\ncolnames and rownames — returns the names of the columns or rows\n\n\n\n2.5.6 Lists\nVectors and data frames are the main two types of objects that we’ll use this semester, but let me give you a quick overview of a few other types of objects. Let’s start with lists. Lists are very generic in the sense that they can carry around complicated data. If you are familiar with any object oriented programming language like Java or C++, they have the flavor of an “object”, in the object-oriented sense.\nI’m not sure if we will see any examples this semester where you have to use a list. But here is an example. Suppose that we wanted to put the vector that we created earlier five and the data frame that we created earlier firm_data into the same object. We could do it as follows\n\nunusual_list &lt;- list(numbers=five, df=firm_data)\n\nYou can access the elements of a list in a few different ways. Sometimes it is convenient to access them via the $\n\nunusual_list$numbers\n\n[1] 1 2 3 4 5\n\n\nOther times, it is convenient to access them via their position in the list\n\nunusual_list[[2]] # notice the double brackets\n\n                  name      industry county employees\n1    ABC Manufacturing Manufacturing Clarke       531\n2     Martin's Muffins Food Services Oconee         6\n3 Down Home Appliances Manufacturing Clarke        15\n4 Classic City Widgets Manufacturing Clarke       211\n5   Watkinsville Diner Food Services Oconee        25\n\n\n\n\n2.5.7 Matrices\nMatrices are very similar to data frames, but the data should all be of the same type. Matrices are very useful in some numerical calculations that are beyond the scope of this class. Here is an example of a matrix.\n\nmat &lt;- matrix(c(1,2,3,4), nrow=2, byrow=TRUE)\nmat\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n\nYou can access elements of a matrix by their position in the matrix, just like for the data frame above.\n\n# first row, second column\nmat[1,2]\n\n[1] 2\n\n# all rows in second column\nmat[,2] \n\n[1] 2 4\n\n\n\n\n2.5.8 Factors\nSometimes variables in economics are categorical. This sort of variable is somewhat between a numeric variable and a string. In R, categorical variables are called factors.\nA good example of a categorical variable is firm_data$industry. It tells you the “category” of the industry that a firm is in.\nOftentimes, we may have to tell R that a variable is a “factor” rather than just a string. Let’s create a variable called industry that contains the industry from firm_data but as a factor.\n\nindustry &lt;- as.factor(firm_data$industry)\nindustry\n\n[1] Manufacturing Food Services Manufacturing Manufacturing Food Services\nLevels: Food Services Manufacturing\n\n\nA useful package for working with factor variables is the forcats package.\n\n\n2.5.9 Understanding an object in R\nSometimes you may be in the case where there is a variable where you don’t know what exactly it contains. Some functions that are helpful in this case are\n\nclass — tells you, err, the class of an object (i.e., its “type”)\nhead — shows you the “beginning” of an object; this is especially helpful for large objects (like some data frames)\nstr — stands for “structure” of an object\n\nLet’s try these out\n\nclass(firm_data)\n\n[1] \"data.frame\"\n\n# typically would show the first five rows of a data frame,\n# but that is the whole data frame here\nhead(firm_data) \n\n                  name      industry county employees\n1    ABC Manufacturing Manufacturing Clarke       531\n2     Martin's Muffins Food Services Oconee         6\n3 Down Home Appliances Manufacturing Clarke        15\n4 Classic City Widgets Manufacturing Clarke       211\n5   Watkinsville Diner Food Services Oconee        25\n\nstr(firm_data)\n\n'data.frame':   5 obs. of  4 variables:\n $ name     : chr  \"ABC Manufacturing\" \"Martin's Muffins\" \"Down Home Appliances\" \"Classic City Widgets\" ...\n $ industry : chr  \"Manufacturing\" \"Food Services\" \"Manufacturing\" \"Manufacturing\" ...\n $ county   : chr  \"Clarke\" \"Oconee\" \"Clarke\" \"Clarke\" ...\n $ employees: num  531 6 15 211 25\n\n\n\nPractice: Try running class, head, and str on the vector five that we created earlier.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#logicals",
    "href": "01-statistical_programming.html#logicals",
    "title": "2  Statistical Programming",
    "section": "2.6 Logicals",
    "text": "2.6 Logicals\nRelated Reading: IDS 2.13\nAll programming languages have ways of tracking whether variables meet certain criteria. These are often called Booleans or Logicals. For us, this will particularly come up in the context of subsetting data (i.e., selecting data based on some condition) and in running particular portions of code based on some condition.\nSome main logical operators are ==, &lt;=, &gt;=, &lt;, &gt; corresponding to whether or not two things are equal, less than or equal to, greater than or equal, strictly less than, and strictly greater than. These can be applied to vectors. And the comparisons result in either TRUE or FALSE. Here are some examples\n\nfive &lt;- c(1,2,3,4,5)\n\n# only 3 is equal to 3\nfive == 3\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\n# 1,2,3 are all less than or equal to 3\nfive &lt;= 3\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\n# 3,4,5, are all greater than or equal to 3\nfive &gt;= 3\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n# 1,2 are strictly less than 3\nfive &lt; 3\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\n# 4,5 are strictly greater than 3\nfive &gt; 3\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\nOften, we might be interested in learning about a subset of our data. As a simple example, using our firm_data from earlier, you could imagine being interested in average employment for manufacturing firms.\nWe can do this using the subset function along with the logical operations we’ve learned in this section.\n\nmanufacturing_firms &lt;- subset(firm_data, industry==\"Manufacturing\")\nmean(manufacturing_firms$employees)\n\n[1] 252.3333\n\n\nAs practice, try creating a subset of firm_data based on firms having more than 100 employees.\n\n\n2.6.1 Additional Logical Operators\nRelated Reading: IDS 2.13\nThere are a number of additional logical operators that can be useful in practice. Here, we quickly cover several more.\n\n!= — not equal\n\nc(1,2,3) != 3\n\n[1]  TRUE  TRUE FALSE\n\n\nWe can link together multiple logical comparisons. If we want to check whether multiple conditions hold, we can use “logical AND” &; if we want to check whether any of multiple conditions hold, we can use “logical OR” |.\n\n# AND\n( c(1,2,3,4,5) &gt;= 3 ) & ( c(1,2,3,4,5) &lt; 5 )\n\n[1] FALSE FALSE  TRUE  TRUE FALSE\n\n# OR\n( c(1,2,3,4,5) &gt;= 4 ) | ( c(1,2,3,4,5) &lt; 2 )\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE\n\n\n%in% — checks whether the elements of one vector show up in another vector\n\n# 1 is in the 2nd vector, but 7 is not\nc(1,7) %in% c(1,2,3,4,5)\n\n[1]  TRUE FALSE\n\n\nOften it is useful to check whether any logical conditions are true or all logical conditions are true. This can be done as follows\n\n# this one is TRUE because 1 is in the 2nd vector  \nany(c(1,7) %in% c(1,2,3,4,5))\n\n[1] TRUE\n\n# this one is FALSE because 7 is not in the 2nd vector\nall(c(1,7) %in% c(1,2,3,4,5))\n\n[1] FALSE",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#programming-basics",
    "href": "01-statistical_programming.html#programming-basics",
    "title": "2  Statistical Programming",
    "section": "2.7 Programming basics",
    "text": "2.7 Programming basics\n\n2.7.1 Writing functions\nRelated Reading: IDS 3.2\nIt is often helpful to write your own functions in R. If you ever find yourself repeating the same code over and over, this suggests that you should write this code as a function and repeatedly call the function.\nSuppose we are interesting in solving the quadratic equation \\[\n  ax^2 + bx + c = 0\n\\] If you remember the quadratic formula, the solution to this equation is \\[\n  x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\n\\] It would be tedious to calculate this by hand (especially if we wanted to calculate it for many different values of \\(a\\), \\(b\\), and \\(c\\)), so let’s write a function to do it.\n\nquadratic_solver &lt;- function(a, b, c) {\n  root1 &lt;- ( -b + sqrt(b^2 - 4*a*c) ) / 2*a\n  root1\n}\n\nBefore we try this out, let’s notice a few things. First, while this particular function is for solving the quadratic equation, this is quite representative of what a function looks like in R.\n\nquadratic_solver — This is the name of the function. It’s good to give your function a descriptive name related to what it does. But you could call it anything you want. If you wanted to call this function uga, it would still work.\nthe part &lt;- function finishes off assigning the function the name quadratic_solver and implies that we are writing down a function rather than a vector or data.frame or something else. This part will show up in all function definitions.\nthe part (a, b, c), a, b, and c are the names of the arguments to the function. In a minute when we call the function, we need to tell the function the particular values of a, b, and c for which to solve the quadratic equation. We could name these whatever we want, but, again, it is good to have descriptive names. When you write a different function, it can have as many arguments as you want it to have.\nthe part { ... } everything that the function does should go between the curly brackets\nthe line root1 &lt;- ( -b + sqrt(b^2 - 4*a*c) ) / 2*a contains the main thing that is calculated by our function. Notice that we only calculate one of the “roots” (i.e., solutions to the quadratic equation) because of the \\(+\\) in this expression.\nthe line root1 R returns whatever variable is on the last line of the function. It might be somewhat more clear to write return(root1). The behavior of the code would be exactly the same, but it is just the more common “style” in R programming to not include the explicit return.\n\nNow let’s try out our function\n\n# solves quadratic equation for a=1, b=4, c=3\nquadratic_solver(1,4,3)\n\n[1] -1\n\n# solves quadratic equation for a=-1, b=5, c=10\nquadratic_solver(-1,5,10)\n\n[1] -1.531129\n\n\nTwo last things that are worth pointing out about functions:\n\nFunctions in R can be set up to take default values for some of their arguments\nBecause the arguments have names, if you are explicit about the name of the argument, then the order of the argument does not matter.\n\nTo give examples, let’s write a slightly modified version of our function to solve quadratic equations.\n\nquadratic_solver2 &lt;- function(a=1, b, c) {\n  root1 &lt;- ( -b + sqrt(b^2 - 4*a*c) ) / 2*a\n  root1\n}\n\nThe only thing different here is that a takes the default value of 1. Now let’s try some different calls to quadratic_solver and quadratic_solver2\n\n# solve again for a=1,b=4,c=3\nquadratic_solver2(b=4,c=3)\n\n[1] -1\n\n# replace default and change order\nquadratic_solver2(c=10,b=5,a=-1)\n\n[1] -1.531129\n\n# no default set for quadratic_solver so it will crash if a not provided\nquadratic_solver(b=4,c=3)\n\nError in quadratic_solver(b = 4, c = 3): argument \"a\" is missing, with no default\n\n\n\n\n2.7.2 if/else\nRelated Reading: IDS 3.1\nOften when writing code, you will want to do different things depending on some condition. Let’s write a function that takes in the number of employees that are in a firm and prints “large” if the firm has more than 100 employees and “small” otherwise.\n\nlarge_or_small &lt;- function(employees) {\n  if (employees &gt; 100) {\n    print(\"large\")\n  } else {\n    print(\"small\")\n  }\n}\n\nI think, at this point, this code should make sense to you. The only new thing is the if/else. The following is not code that will actually run but is just to help understand the logic of if/else.\n\nif (condition) {\n  # do something\n} else {\n  # do something else\n}\n\nAll that happens with if/else is that we check whether condition evaluate to TRUE or FALSE. If it is TRUE, the code will do whatever is inside the first set of brackets; if it is FALSE, the code will do whatever is in the set of brackets following else.\n\n\n2.7.3 for loops\nRelated Reading: IDS 3.4\nOften, we need to run the same code over and over again. A for loop is a main programming tool for this case (for loops show up in pretty much all programming languages).\nWe’ll have more realistic examples later on in the semester, but we’ll do something trivial for now.\n\nout &lt;- c()\nfor (i in 1:10) {\n  out[i] &lt;- i*3\n}\nout\n\n [1]  3  6  9 12 15 18 21 24 27 30\n\n\nThe above code, starts with \\(i=1\\), calculates \\(i*3\\) (which is 3), and then stores that result in the first element of the vector out, then \\(i\\) increases to 2, the code calculates \\(i*3\\) (which is now 6), and stores this result in the second element of out, and so on through \\(i=10\\).\n\n\n2.7.4 Vectorization\nRelated Reading: IDS 3.5\nVectorizing functions is a relatively advanced topic in R programming, but it is an important one, so I am including it here.\nBecause we will often be working with data, we will often be performing the same operation on all of the observations in the data. For example, suppose that you wanted to take the logarithm of the number of employees for all the firms in firm_data. One way to do this is to use a for loop, but this code would be a bit of a mess. Instead, the function log is vectorized — this means that if we apply it to a vector, it will calculate the logarithm of each element in the vector. Besides this, vectorized functions are often faster than for loops.\nNot all functions are vectorized though. Let’s go back to our function earlier called large_or_small. This took in the number of employees at a firm and then printed “large” if the firm had more than 100 employees and “small” otherwise. Let’s see what happens if we call this function on a vector of employees (Ideally, we’d like the function to be applied to each element in the vector).\n\nemployees &lt;- firm_data$employees\nemployees\n\n[1] 531   6  15 211  25\n\nlarge_or_small(employees)\n\nError in if (employees &gt; 100) {: the condition has length &gt; 1\n\n\nThis is not what we wanted to have happen. Instead of determining whether each firm was large or small, we get an error basically said that something may be going wrong here. What’s going on here is that the function large_or_small is not vectorized.\nIn order to vectorize a function, we can use one of a number of “apply” functions in R. I’ll list them here\n\nsapply — this stands for “simplify” apply; it “applies” the function to all the elements in the vector or list that you pass in and then tries to “simplify” the result\nlapply — stands for “list” apply; applies a function to all elements in a vector or list and then returns a list\nvapply — stands for “vector” apply; applies a function to all elements in a vector or list and then returns a vector\napply — applies a function to either the rows or columns of a matrix-like object (i.e., a matrix or a data frame) depending on the value of the argument MARGIN\n\nLet’s use sapply to vectorize large_or_small.\n\nlarge_or_small_vectorized &lt;- function(employees_vec) {\n  sapply(employees_vec, FUN = large_or_small)\n}\n\nAll that this will do is call the function large_or_small for each element in the vector employees. Let’s see it in action\n\nlarge_or_small_vectorized(employees)\n\n[1] \"large\"\n[1] \"small\"\n[1] \"small\"\n[1] \"large\"\n[1] \"small\"\n\n\n[1] \"large\" \"small\" \"small\" \"large\" \"small\"\n\n\nThis is what we were hoping for.\n\nSide Comment: I also typically replace most all for loops with an apply function. In most cases, I don’t think there is much of a performance gain, but the code seems easier to read (or at least more concise).\nEarlier we wrote a function to take a vector of numbers from 1 to 10 and multiply all of them by 3. Here’s how you could do this using sapply\n\nsapply(1:10, function(i) i*3)\n\n [1]  3  6  9 12 15 18 21 24 27 30\n\n\nwhich is considerably shorter.\nOne last thing worth pointing out though is that multiplication is already vectorized, so you don’t actually need to do sapply or the for loop; a better way is just\n\n(1:10)*3\n\n [1]  3  6  9 12 15 18 21 24 27 30\n\n\n\n\nSide Comment: A relatively popular alternative to apply functions are map functions provided in the purrr package.\n\n\nSide Comment: It’s often helpful to have a vectorized version of if/else. In R, this is available in the function ifelse. Here is an alternative way to vectorize the function large_or_small:\n\nlarge_or_small_vectorized2 &lt;- function(employees_vec) {\n  ifelse(employees_vec &gt; 100, \"large\", \"small\")\n}\nlarge_or_small_vectorized2(firm_data$employees)\n\n[1] \"large\" \"small\" \"small\" \"large\" \"small\"\n\n\nHere you can see that ifelse makes every comparison in its first argument, and then returns the second element for every TRUE coming from the first argument, and returns the third element for every FALSE coming from the first argument.\nifelse also works with vectors in the second and third element. For example:\n\n  ifelse(c(1,3,5) &lt; 4, yes=c(1,2,3), no=c(4,5,6))\n\n[1] 1 2 6\n\n\nwhich picks up 1 and 2 from the second (yes) argument and 6 from the third (no) argument.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#advanced-topics",
    "href": "01-statistical_programming.html#advanced-topics",
    "title": "2  Statistical Programming",
    "section": "2.8 Advanced Topics",
    "text": "2.8 Advanced Topics\nTo conclude this section, I want to briefly point you towards some advanced material. We will probably brush up against some of this material this semester. That being said, R has some very advanced capabilities related to data science, data manipulation, and data visualization. If you have time/interest you might push further in all of these directions. By the end of the semester, we may not have mastered these topics, but they should at least be accessible to you.\n\n2.8.1 Tidyverse\nRelated Reading: IDS Chapter 4 — strongly recommend that you read this\n\nR has very good data cleaning / manipulating tools\n\nMany of them are in the “tidyverse”\nMostly this semester, I’ll just give you a data set that is ready to be worked with. But as you move to your own research projects or do work for a company one day, you will realize that a major step in analyzing data is organizing (“cleaning”) the data in a way that you can analyze it\n\nMain packages\n\nggplot2 – see below\ndplyr — package to manipulate data\ntidyr — more ways to manipulate data\nreadr — read in data\npurrr — alternative versions of apply functions and for loops\ntibble — alternative versions of data.frame\nstringr — tools for working with strings\nforcats — tools for working with factors\n\nI won’t emphasize these too much as they are somewhat advanced topics, but if you are interested, these are good (and marketable) skills to have\n\n\n\n2.8.2 Data Visualization\nRelated Reading: IDS Ch. 6-11 — R has very good data visualization tools; strongly recommend that you read this\n\nAnother very strong point of R\nBase R comes with the plot command, but the ggplot2 package provides cutting edge plotting tools. These tools will be somewhat harder to learn, but we’ll use ggplot2 this semester as I think it is worth it.\n538’s graphs produced with ggplot\n\n\n\n2.8.3 Reproducible Research\nRelated Reading: IDS Ch. 40\n\nRmarkdown is a very useful way to mix code and content\nThese notes are written in Rmarkdown, and I usually write homework solutions in Rmarkdown\nIf you are interested, you can view the source for this book at http://github.com/bcallaway11/econ_4750_notes. The source code for this chapter is in the file 01-statistical-programming.Rmd.\nIf you are interested, Github is a very useful version control tool (i.e., keeps track of the version of your project, useful for merging projects, and sharing or co-authoring code) and Dropbox (also useful for sharing code). I use both of these extensively — in general, I use Github relatively more for bigger projects and more public projects and Dropbox more for smaller projects and early versions of projects.\n\n\n\n2.8.4 Technical Writing Tools\nThis is largely beyond the scope of the course, but, especially for students in ECON 6750, I recommend that you look up Latex. This is a markup language mainly for writing technical, academic writing. The big payoff is on writing mathematical equations. The equations in the Course notes are written in Latex.\nAn easy way to get started here is to use the website Overleaf. This is also closely related to markdown/R-markdown discussed above (Latex tends to be somewhat more complicate which comes with some associated advantages and disadvantages).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#lab-1-introduction-to-r-programming",
    "href": "01-statistical_programming.html#lab-1-introduction-to-r-programming",
    "title": "2  Statistical Programming",
    "section": "2.9 Lab 1: Introduction to R Programming",
    "text": "2.9 Lab 1: Introduction to R Programming\nFor this lab, we will do several practice problems related to programming in R.\n\nCreate two vectors as follows\n::: {.cell}\nx &lt;- seq(2,10,by=2)\ny &lt;- c(3,5,7,11,13)\n:::\nAdd x and y, subtract y from x, multiply x and y, and divide x by y and report your results.\nThe geometric mean of a set of numbers is an alternative measure of central tendency to the more common “arithmetic mean” (this is the mean that we are used to). For a set of \\(J\\) numbers, \\(x_1,x_2,\\ldots,x_J\\), the geometric mean is defined as\n\\[\n   (x_1 \\cdot x_2 \\cdot \\cdots \\cdot x_J)^{1/J}\n\\]\nWrite a function called geometric_mean that takes in a vector of numbers and computes their geometric mean. Compute the geometric mean of c(10,8,13)\nUse the lubridate package to figure out how many days it has been since Jan. 1, 1981.\nmtcars is one of the data frames that comes packaged with base R.\n\nHow many observations does mtcars have?\nHow many columns does mtcars have?\nWhat are the names of the columns of mtcars?\nPrint only the rows of mtcars for cars that get at least 20 mpg\nPrint only the rows of mtcars that get at least 20 mpg and have at least 100 horsepower (it is in the column called hp)\nPrint only the rows of mtcars that have 6 or more cylinders (it is in the column labeld cyl) or at least 100 horsepower\nRecover the 10th row of mtcars\nSort the rows of mtcars by mpg (from highest to lowest)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#lab-1-solutions",
    "href": "01-statistical_programming.html#lab-1-solutions",
    "title": "2  Statistical Programming",
    "section": "2.10 Lab 1: Solutions",
    "text": "2.10 Lab 1: Solutions\n\n\n\n\nx &lt;- seq(2,10,by=2)\ny &lt;- c(3,5,7,11,13)\n\nx+y\n\n[1]  5  9 13 19 23\n\nx-y\n\n[1] -1 -1 -1 -3 -3\n\nx*y\n\n[1]   6  20  42  88 130\n\nx/y\n\n[1] 0.6666667 0.8000000 0.8571429 0.7272727 0.7692308\n\n\n\n\n\n\ngeometric_mean &lt;- function(x) {\n  J &lt;- length(x)\n  res &lt;- prod(x)^(1/J)\n  res\n}\n\ngeometric_mean(c(10,8,13))\n\n[1] 10.13159\n\n\n\n\n\n\nthe_date &lt;- lubridate::mdy(\"01-01-1981\")\ntoday &lt;- lubridate::mdy(\"08-23-2021\")\ntoday - the_date\n\nTime difference of 14844 days\n\n\n\n\n::: {.cell}\nnrow(mtcars)\n::: {.cell-output .cell-output-stdout}\n[1] 32\n::: :::\n::: {.cell}\nncol(mtcars)\n::: {.cell-output .cell-output-stdout}\n[1] 11\n::: :::\n::: {.cell}\ncolnames(mtcars)\n::: {.cell-output .cell-output-stdout}\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n::: :::\n::: {.cell}\nsubset(mtcars, mpg &gt;= 20)\n::: {.cell-output .cell-output-stdout}\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n::: :::\n::: {.cell}\nsubset(mtcars, (mpg &gt;= 20) & (hp &gt;= 100))\n::: {.cell-output .cell-output-stdout}\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n::: :::\n::: {.cell}\nsubset(mtcars, (cyl &gt;= 6) | (hp &gt;= 100))\n::: {.cell-output .cell-output-stdout}\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n::: :::\n::: {.cell}\nmtcars[10,]\n::: {.cell-output .cell-output-stdout}\n          mpg cyl  disp  hp drat   wt qsec vs am gear carb\nMerc 280 19.2   6 167.6 123 3.92 3.44 18.3  1  0    4    4\n::: :::\n::: {.cell}\n# without reversing the order, we would order from lowest to smallest\nmtcars[rev(order(mtcars$mpg)),]\n::: {.cell-output .cell-output-stdout}\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n::: :::",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  },
  {
    "objectID": "01-statistical_programming.html#coding-exercises",
    "href": "01-statistical_programming.html#coding-exercises",
    "title": "2  Statistical Programming",
    "section": "2.11 Coding Exercises",
    "text": "2.11 Coding Exercises\n\nThe stringr package contains a number of functions for working with strings. For this problem create the following character vector in R\n::: {.cell}\nx &lt;- c(\"economics\", \"econometrics\", \"ECON 4750\")\n:::\nInstall the stringr package and use the str_length function in the package in order to calculate the length (number of characters) in each element of x.\nFor this problem, we are going to write a function to calculate the sum of the numbers from 1 to \\(n\\) where \\(n\\) is some positive integer. There are actually a lot of different ways to do this.\n\nApproach 1: write a function called sum_one_to_n_1 that uses the R functions seq to create a list of numbers from 1 to \\(n\\) and then the function sum to sum over that list.\nApproach 2: The sum of numbers from 1 to \\(n\\) is equal to \\(n(n+1)/2\\). Use this expression to write a function called sum_one_to_n_2 to calculate the sum from 1 to \\(n\\).\n\nApproach 3: A more brute force approach is to create a list of numbers from 1 to \\(n\\) (you can use seq here) and add them up using a for loop — basically, just keep track of what the current total is and add the next number to the total in each iteration of the for loop. Write a function called sum_one_to_n_3 that does this.\n\nHint: All of the functions should look like\n::: {.cell}\nsum_one_to_n &lt;- function(n) {\n  # do something\n}\n:::\nTry out all three approaches that you came up with above for \\(n=100\\). What is the answer? Do you get the same answer using all three approaches?\nThe Fibonacci sequence is the sequence of numbers \\(0,1,1,2,3,5,8,13,21,34,55,\\ldots\\) that comes from starting with \\(0\\) and \\(1\\) and where each subsequent number is the sum of the previous two. For example, the 5 in the sequence comes from adding 2 and 3; the 55 in the sequence comes from adding 21 and 34.\n\nWrite a function called fibonacci that takes in a number n and computes the nth element in the Fibonacci sequence. For example fibonacci(5) should return 3 and fibonacci(8) should return 13.\nConsider an alternative sequence where, starting with the third element, each element is computed as the sum of the previous two elements (the same as with the Fibonacci sequence) but where the first two elements can be arbitrary. Write a function alt_seq(a,b,n) where a is the first element in the sequence, b is the second element in the sequence, and n is which element in the sequence to return. For example, if \\(a=3\\) and \\(b=7\\), then the sequence would be \\(3,7,10,17,27,44,71,\\ldots\\) and alt_seq(a=3,b=7,n=4) = 17.\n\nThis problem involves writing functions related to computing prime numbers. Recall that a prime number is a positive integer whose only (integer) factors are 1 and itself (e.g., \\(6\\) is not prime because it factors into \\(2\\times 3\\), but \\(5\\) is a prime number because its only factors are \\(1\\) and \\(5\\)).\nFor this problem, you cannot use any built-in functions in R for computing prime numbers or checking whether or not a number is a prime number. However, a helpful function for this problem is the modulo function, %% discussed earlier in the notes. Hint: Notice that 6 %% 2 = 0 indicates that 2 is a factor of 6; on the other hand, if you divide \\(5\\) by any integer small than itself (except for \\(1\\)), the remainder will always be non-zero.\n\nWrite a function is_prime that takes x as an argument and returns TRUE if x is a prime number and returns FALSE if x is not a prime number.\nWrite a function prime that takes n as an argument and returns a vector of all the prime numbers from \\(1\\) to \\(n\\). If it is helpful, prime can call the function is_prime that you wrote for part (a).\n\nBase R includes a data frame called iris. This is data about iris flowers (you can read the details by running ?iris).\n\nHow many observations are there in the entire data frame?\nCalculate the average Sepal.Length across all observations in iris.\nCalculate the average Sepal.Width among the setosa iris species.\nSort iris by Petal.Length and print the first 10 rows.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Statistical Programming</span>"
    ]
  }
]