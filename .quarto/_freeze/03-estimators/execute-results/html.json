{
  "hash": "5c9473f7a3e373b0ae04a78873f254e5",
  "result": {
    "engine": "knitr",
    "markdown": "# Properties of Estimators\n\nSo far, we have been talking about **population quantities** such as $f_{Y|X}$ (conditional pdf/pmf), $\\E[Y]$ (expected value of $Y$), or $\\E[Y|X]$ (expected value of $Y$ given $X$).\n\nIn practice, most often we do not know what these population quantities are equal to (with the exception of some trivial cases like flipping a coin or rolling a die).\n\nA fundamental challenge is that it is uncommon that we observe the entire population.\n\nInstead, we will take the approach that we have access to a **sample** of data from the original population.  We'll use the sample to try to **estimate** whatever population quantities we are interested in as well as develop the tools to **conduct inference**, paying particular interest to questions like: how precisely can we estimate particular population quantities of interest?  \n\nThe topics considered in this section fall broadly under the topic of **statistics** (a reasonable definition of statistics is that it is the set of tools to learn about population quantities using data).  Some of this material may be familiar from courses that you have taken before, but this section provides a fairly advanced discussion of these issues with a particular eye towards (i) inference issues that are important econometrics and (ii) prediction problems.  Many of the tools that we cover in this section will be used throughout the rest of the course.\n\n\n## Simple Random Sample\n\nSW 2.5\n\nLet's start by talking about how the data that we have access to is collected.  There are several possibilities here, but let us start with the most straightforward case (which is also a very common case) called a **simple random sample**.  \n\nIn math: $\\{Y_i\\}_{i=1}^n$ is called a simple random sample if $Y_1, Y_2, \\ldots, Y_n$ are independent random variables with a common probability distribution $f_Y$.  The two key conditions here are (i) independence and (ii) from a common distribution.  For this reason, you may sometimes see a random sample called an iid sample which stands for independent and identically distributed.\n\nIn words: We have access to $n$ observations that are drawn at random from some underlying population and each observation is equally likely to be drawn.\n\n## Estimating $\\E[Y]$\n\nSW 2.5, 3.1\n\nLet's start with trying to estimate $\\E[Y]$ as this is probably the simplest, non-trivial thing that we can estimate.  \n\nA natural way to estimate population quantities is with their sample analogue.  This is called the **analogy principle**.  This is perhaps technical jargon, but it is the way you would immediately think to estimate $\\E[Y]$:\n\n$$\n  \\hat{\\E}[Y] = \\frac{1}{n} \\sum_{i=1}^n Y_i = \\bar{Y}\n$$\nIn this course, we will typically put a \"hat\" on estimated quantities.  The expression $\\displaystyle \\frac{1}{n}\\sum_{i=1}^n Y_i$ is just the average value of $Y$ in our sample.  Since we will calculate a ton of averages like this one over the course of the rest of the semester, it's also convenient to give it a shorthand notation, which is what $\\bar{Y}$ means --- it is just the sample average of $Y$.\n\nOne thing that is important to be clear about at this point is that, in general, $\\E[Y] \\neq \\bar{Y}$.  $\\E[Y]$ is a population quantity while $\\bar{Y}$ is a sample quantity.  We will hope (and provide some related conditions/discussions below) that $\\bar{Y}$ would be close to $\\E[Y]$, but, in general, they will not be exactly the same.\n\n## Mean of $\\bar{Y}$\n\nSW 2.5, 3.1\n\nAnother important thing to notice about $\\bar{Y}$ is that it is a random variable (as it is the average of random variables).  This is in sharp contrast to $\\E[Y]$ which is non-random.  \n\nOne related thought experiment is the following: if we could repeatedly collect new samples of size $n$ from the same population and each time were able to estimate $\\bar{Y}$, these estimates would be different from each other.\n\nIn fact, this means that $\\bar{Y}$ has a distribution.  The distribution of a statistic, like $\\bar{Y}$, is called its **sampling distribution**.  We'd like to know about the features of the sampling distribution.  Let's start with its mean.  That is, let's calculate\n\n$$\n  \\begin{aligned}\n    \\E[\\bar{Y}] &= \\E\\left[ \\frac{1}{n} \\sum_{i=1}^n Y_i \\right] \\\\\n    &= \\frac{1}{n} \\E\\left[ \\sum_{i=1}^n Y_i \\right] \\\\\n    &= \\frac{1}{n} \\sum_{i=1}^n \\E[Y_i] \\\\\n    &= \\frac{1}{n} \\sum_{i=1}^n \\E[Y] \\\\\n    &= \\frac{1}{n} n \\E[Y] \\\\\n    &= \\E[Y]\n  \\end{aligned}\n$$\nLet's think carefully about each step here --- the arguments rely heavily on the properties of expectations and summations that we have learned earlier.  The first equality holds from the definition of $\\bar{Y}$.  The second equality holds because $1/n$ is a constant and can therefore come out of the expectation.  The third equality holds because the expectation can pass through the sum.  The fourth equality holds because $Y_i$ are all from the same distribution which implies that they all of the same mean and that it is equal to $\\E[Y]$. The fifth equality holds because $\\E[Y]$ is a constant and we add it up $n$ times.  And the last equality just cancels the $n$ in the numerator with the $n$ in the denominator.\n\nBefore moving on, let me make an additional comment:\n\n- The fourth equality might be a little confusing.  Certainly it is not saying that all the $Y_i$'s are equal to each other.  Rather, they come from the same distribution.  For example, if you roll a die $n$ times, you get different outcomes on different rolls, but they are all from the same distribution so that the population expectation of each roll is always 3.5, but you get different realizations on different particular rolls.  Another example is if $Y$ is a person's income.  Again, we are not saying that everyone has the same income, but just that we are thinking of income as being a draw from some distribution --- sometimes you get a draw of a person with a very high income; other times you get a draw of a person with a low income, but $\\E[Y]$ is a feature of the underlying distribution itself where these draws come from.\n\nHow should interpret the above result?  It says that, $\\E[\\bar{Y}] = \\E[Y]$.  This doesn't mean that $\\bar{Y}$ itself is equal to $\\E[Y]$.  Rather, it means that, if we could repeatedly obtain (a huge number of times) new samples of size $n$ and compute $\\bar{Y}$ each time, the average of $\\bar{Y}$ across repeated samples would be equal to $\\E[Y]$.\n\n## Variance of $\\bar{Y}$\n\nSW 2.5, 3.1\n\nNext, let's calculate the variance of $\\bar{Y}$.  As before, we are continuing with the thought experiment of being able to repeatedly draw new samples of size $n$, and, therefore, we call this variance the **sampling variance**.\n\n$$\n  \\begin{aligned}\n    \\Var(\\bar{Y}) &= \\Var\\left(\\frac{1}{n} \\sum_{i=1}^n Y_i\\right) \\\\\n    &= \\frac{1}{n^2} \\Var\\left(\\sum_{i=1}^n Y_i\\right) \\\\\n    &= \\frac{1}{n^2} \\left( \\sum_{i=1}^n \\Var(Y_i) + \\textrm{lots of covariance terms} \\right) \\\\\n    &= \\frac{1}{n^2} \\left( \\sum_{i=1}^n \\Var(Y_i) \\right) \\\\\n    &= \\frac{1}{n^2} \\sum_{i=1}^n \\Var(Y) \\\\\n    &= \\frac{1}{n^2} n \\Var(Y) \\\\\n    &= \\frac{\\Var(Y)}{n}\n  \\end{aligned}\n$$\nLet's go carefully through each step --- these arguments rely heavily on the properties of variance that we talked about earlier.  The first equality holds by the definition of $\\bar{Y}$.  The second equality holds because $1/n$ is a constant and can come out of the variance after squaring it.  The third equality holds because the variance of the sum of random variables is equal to the sum of the variances plus all the covariances between the random variables.  In the fourth equality, all of the covariance terms go away --- this holds because of random sampling which implies that the $Y_i$ are all independent which implies that their covariances are equal to 0.  The fifth equality holds because all $Y_i$ are identically distributed so their variances are all the same and equal to $\\Var(Y)$.  The sixth equality holds by adding up $\\Var(Y)$ $n$ times.  The last equality holds by canceling the $n$ in the numerator with one of the $n$'s in the denominator.\n\nInterestingly, the variance of $\\bar{Y}$ depends not just on $\\Var(Y)$ but also on $n$ --- the number of observations in the sample.  Notice that $n$ is in the denominator, so the variance of $\\bar{Y}$ will be lower for large values of $n$.  Here is an example that may be helpful for understanding this.  Suppose that you are rolling a die.  If $n=1$, then clearly, the variance of $\\bar{Y}$ is just equal to the variance of $Y$ --- sometimes you roll extreme values like $1$ or $6$.  Now, when you increase $n$, say, to 10, then these extreme values of $\\bar{Y}$ are substantially less common.  For $\\bar{Y}$ to be equal to $6$ in this case, you'd need to roll 10 $6$'s in a row.  This illustrates that the sampling variance of $\\bar{Y}$ is decreasing in $n$.  If this is not perfectly clear, we will look at some data soon, and I think that should confirm to you that the variance of $\\bar{Y}$ is decreasing in the sample size.\n\n\n## Properties of Estimators\n\nSW 2.5, 3.1\n\nSuppose we are interested in some population parameter $\\theta$ --- we'll write this pretty generically now, but it could be $\\E[Y]$ or $\\E[Y|X]$ or really any other population quantity that you'd like to estimate.  \n\nAlso, suppose that we have access to a random sample of size $n$ and we have some estimate of $\\theta$ that we'll call $\\hat{\\theta}$.  \n\nAs before, we are going to consider the repeated sampling thought experiment where we imagine that we could repeatedly obtain new samples of size $n$ and with each new sample calculate a new $\\hat{\\theta}$.  Under this thought experiment, $\\hat{\\theta}$ would have a sampling distribution.  One possibility for what it could look like is the following\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nIn this case, values of $\\hat{\\theta}$ are more common around 3 and 4, but it is not highly unusual to get a value of $\\hat{\\theta}$ that is around 1 or 2 or 5 or 6 either.\n\nThe first property of an estimator that we will take about is called **unbiasedness**.  An estimator $\\hat{\\theta}$ is said to be unbiased if $\\E[\\hat{\\theta}] = \\theta$.  Alternatively, we can define the **bias** of an estimator as \n\n$$\n  \\textrm{Bias}(\\hat{\\theta}) = \\E[\\hat{\\theta}] - \\theta\n$$\nFor example, if $\\textrm{Bias}(\\hat{\\theta}) > 0$, it means that, on average (in the repeated sampling thought experiment), our estimates of $\\theta$ would be greater than the actual value of $\\theta$.  \n\nIn general, unbiasedness is a good property for an estimator to have.  That being said, we can come up with examples of not-very-good unbiased estimators and good biased estimators, but all-else-equal, it is better for an estimator to be unbiased.\n\nThe next property of estimators that we will talk about is their **sampling variance**.  This is just $\\Var(\\hat{\\theta})$.  In general, we would like estimators with low (or 0) bias and low sampling variance.  Let me give an example\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nThis is a helpful figure for thinking about the properties of estimators.  In this case, $\\hat{\\theta}_1$ and $\\hat{\\theta}_2$ are both unbiased (because their means are $\\theta$) while $\\hat{\\theta}_3$ is biased --- it's mean is greater than $\\theta$.  On the other hand the sampling variance of $\\hat{\\theta}_2$ and $\\hat{\\theta}_3$ are about the same and both substantially smaller than for $\\hat{\\theta}_1$.  Clearly, $\\hat{\\theta}_2$ is the best estimator of $\\theta$ out of the three.  But which is the second best?  It is not clear.  $\\hat{\\theta}_3$ systematically over-estimates $\\theta$, but since the variance is relatively small, the misses are systematic but tend to be relatively small.  On the other hand, $\\hat{\\theta}_1$ is, on average, equal to $\\theta$, but sometimes the estimate of $\\theta$ could be quite poor due to the large sampling variance.\n\n## Relative Efficiency\n\nSW 3.1\n\nIf $\\hat{\\theta}_1$ and $\\hat{\\theta}_2$ are two unbiased estimators of $\\theta$, then $\\hat{\\theta}_1$ is **more efficient** than $\\hat{\\theta}_2$ if $\\Var(\\hat{\\theta}_1) < \\Var(\\hat{\\theta}_2)$.\n\nRelative efficiency gives us a way to rank unbiased estimators.\n\n## Mean Squared Error\n\nMore generally, two estimators can be compared by their **mean squared error** which is defined as \n\n$$\n  \\textrm{MSE}(\\hat{\\theta}) := \\E\\left[ (\\hat{\\theta} - \\theta)^2\\right]\n$$\n\nThe mean squared error of $\\hat{\\theta}$ is the average \"distance\" between $\\hat{\\theta}$ and $\\theta$ in the thought experiment of having repeated samples of size $n$.\n\nAnother equivalent expression for the mean squared error is\n\n$$\n  \\textrm{MSE}(\\hat{\\theta}) = \\textrm{Bias}(\\hat{\\theta})^2 + \\Var(\\hat{\\theta})\n$$\nIn other words, if we can figure out the bias and variance of $\\hat{\\theta}$, then we can recover mean squared error.\n\n::: {.side-comment}\n\n<span class=\"side-comment\">Side-Comment:</span> I think it is worth quickly explaining where the second expression for $\\textrm{MSE}(\\hat{\\theta})$ comes from.  Starting from the definition of $\\textrm{MSE}(\\hat{\\theta})$, \n\n$$\n  \\begin{aligned}\n    \\textrm{MSE}(\\hat{\\theta}) &= \\E\\left[ (\\hat{\\theta} - \\theta)^2\\right] \\\\\n    &= \\E\\left[ \\left( (\\hat{\\theta} - \\E[\\hat{\\theta}]) + (\\E[\\hat{\\theta}] - \\theta)\\right)^2 \\right] \\\\\n    &= \\E\\left[ (\\hat{\\theta} - \\E[\\hat{\\theta}])^2 \\right] + \\E\\left[ (\\E[\\hat{\\theta}] - \\theta)^2\\right] + 2 \\E\\left[ (\\hat{\\theta} - \\E[\\hat{\\theta}])(\\E[\\hat{\\theta}] - \\theta) \\right] \\\\\n    &= \\Var(\\hat{\\theta}) + \\textrm{Bias}(\\hat{\\theta})^2 \n  \\end{aligned}\n$$\nwhere the first equality is just the definition of $\\textrm{MSE}(\\hat{\\theta})$, the second equality adds and subtracts $\\E[\\hat{\\theta}]$, the third equality squares everything in parentheses from the previous line and pushes the expectation through the sum.  For the last equality, the first term in the previous line corresponds to the definition of $\\Var(\\hat{\\theta})$; for the second term, recall that $\\textrm{Bias}(\\hat{\\theta}) = \\E[\\hat{\\theta}-\\theta]$ (and this is non-random so the outside expectation just goes away); the last term is equal to 0 which just holds by the properties of expectations after noticing that $(\\E[\\hat{\\theta}] - \\theta)$ is non-random and can therefore come out of the expectation.\n:::\n\nGenerally, we would like to choose estimators that have low mean squared error (this essentially means that they have low bias and variance).  Moreover, mean squared error gives us a way to compare estimators that are potentially biased.  [Also, notice that for unbiased estimators, comparing mean squared errors of different estimators just compares their variance (because the bias term is equal to 0), so this is a *generalization* of relative efficiency from the previous section.]\n\n::: {.example}\n\nLet's compare three estimators of $\\E[Y]$ based on their mean squared error.  Let's consider the three following estimators\n\n$$\n  \\begin{aligned}\n    \\hat{\\mu} &:= \\frac{1}{n} \\sum_{i=1}^n Y_i \\\\\n    \\hat{\\mu}_1 &:= Y_1 \\\\\n    \\hat{\\mu}_\\lambda &:= \\lambda \\bar{Y} \\quad \\textrm{for some } \\lambda > 0 \n  \\end{aligned}\n$$\n$\\hat{\\mu}$ is just the sample average of $Y$'s that we have already discussed.  $\\hat{\\mu}_1$ is the (somewhat strange) estimator of $\\E[Y]$ that just uses the first observation in the data (regardless of the sample size).  $\\hat{\\mu}_\\lambda$ is an estimator of $\\E[Y]$ that multiplies $\\bar{Y}$ by some positive constant $\\lambda$.\n\nTo calculate the mean squared error of each of these estimators, let's calculate their means and their variances.\n\n$$\n  \\begin{aligned}\n    \\E[\\hat{\\mu}] &= \\E[Y] \\\\\n    \\E[\\hat{\\mu}_1] &= \\E[Y_1] = \\E[Y] \\\\\n    \\E[\\hat{\\mu}_\\lambda] &= \\lambda \\E[\\bar{Y}] = \\lambda \\E[Y]\n  \\end{aligned}\n$$\nThis means that $\\hat{\\mu}$ and $\\hat{\\mu}_1$ are both unbiased.  $\\hat{\\mu}_\\lambda$ is biased (unless $\\lambda=1$ though this is a relatively uninteresting case as it would mean that $\\hat{\\mu}_\\lambda$ is exactly the same as $\\hat{\\mu}$) with $\\textrm{Bias}(\\hat{\\mu}_\\lambda) = (\\lambda - 1) \\E[Y]$.\n\nNext, let's calculate the variance for each estimator\n\n$$\n  \\begin{aligned}\n  \\Var(\\hat{\\mu}) &= \\frac{\\Var(Y)}{n} \\\\\n  \\Var(\\hat{\\mu}_1) &= \\Var(Y_1) = \\Var(Y) \\\\\n  \\Var(\\hat{\\mu}_\\lambda) &= \\lambda^2 \\Var(\\bar{Y}) = \\lambda^2 \\frac{\\Var(Y)}{n}\n  \\end{aligned}\n$$\nThis means that we can now calculate mean squared error for each estimator.\n\n$$\n  \\begin{aligned}\n    \\textrm{MSE}(\\hat{\\mu}) &= \\frac{\\Var{Y}}{n} \\\\\n    \\textrm{MSE}(\\hat{\\mu}_1) &= \\Var(Y) \\\\\n    \\textrm{MSE}(\\hat{\\mu}_\\lambda) &= (\\lambda-1)^2\\E[Y]^2 + \\lambda^2 \\frac{\\Var(Y)}{n}\n  \\end{aligned}\n$$\nThe first thing to notice is that $\\hat{\\mu}$ *dominates* $\\hat{\\mu}_1$ (where dominates means that there isn't any scenario where you could make a reasonable case that $\\hat{\\mu}_1$ is a better estimator) because its MSE is strictly lower (they tie only if $n=1$ when they become the same estimator).  This is probably not surprising --- $\\hat{\\mu}_1$ just throws away a lot of potentially useful information.\n\nThe more interesting case is $\\hat{\\mu}_\\lambda$.  The first term is the bias term --- it is greater than the bias from $\\hat{\\mu}$ or $\\hat{\\mu}_1$ because the bias of both of these is equal to 0.  However, relative to $\\hat{\\mu}$, the variance of $\\hat{\\mu}_\\lambda$ can be smaller when $\\lambda$ is less than 1.  In fact, you can show that there are estimators that have smaller mean squared error than $\\hat{\\mu}$ by choosing a $\\lambda$ that is smaller than (usually just slightly smaller than) 1.  This sort of estimator would be biased, but are able to compensate introducing some bias by having smaller variance.  For now, we won't talk much about this sort of estimator (and stick to $\\bar{Y}$), but this sort of estimator has the \"flavor\" of modern machine learning estimators that typically introduce some bias while reducing variance.  One last comment: if you were to make a \"bad\" choice of $\\lambda$, $\\hat{\\mu}_\\lambda$ could have higher mean squared error than even $\\hat{\\mu}_1$, so if you wanted to proceed this way, you'd have to choose $\\lambda$ with some care.\n\n:::\n\n## Large Sample Properties of Estimators\n\nSW 2.6\n\nStatistics/Econometrics often relies on \"large sample\" (meaning: the number of observations, $n$, is large) properties of estimators.\n\nIntuition: We generally expect that estimators that use a large number of observations will perform better than in the case with only a few observations.\n\nThe second goal of this section will be to introduce an approach to conduct hypothesis testing.  In particular, we may have some theory and want a way to test whether or not the data that we have \"is consistent with\" the theory or not.  These arguments typically involve either making strong assumptions or having a large sample --- we'll mainly study the large sample case as I think this is more useful.\n\n\n## Consistency\n\nAn estimator $\\hat{\\theta}$ of $\\theta$ is said to be **consistent** if $\\hat{\\theta}$ gets close to $\\theta$ for large values of $n$.\n\nThe main tool for studying consistency is the **law of large numbers**.  The law of large numbers says that sample averages converge to population averages as the sample size gets large.  In math, this is\n\n$$\n  \\frac{1}{n} \\sum_{i=1}^n Y_i \\rightarrow \\E[Y] \\quad \\textrm{as } n \\rightarrow \\infty\n$$\nIn my view, the law of large numbers is very intuitive.  If you have a large sample and calculate a sample average, it should be close to the population average.\n\n::: {.example}\n\nLet's consider the same three estimators as before and whether or not they are consistent.  First, the LLN implies that\n\n$$\n  \\hat{\\mu} = \\frac{1}{n} \\sum_{i=1}^n Y_i \\rightarrow \\E[Y]\n$$\nThis implies that $\\hat{\\mu}$ is consistent.  Next,\n\n$$\n  \\hat{\\mu}_1 = Y_1\n$$\ndoesn't change depending on the size of the sample (you just use the first observation), so this is not consistent.  This is an example of an unbiased estimator that is not consistent.  Next,\n\n$$\n  \\hat{\\mu}_\\lambda = \\lambda \\bar{Y} \\rightarrow \\lambda \\E[Y] \\neq \\E[Y]\n$$\nwhich implies that (as long as $\\lambda$ doesn't change with $n$), $\\hat{\\mu}_{\\lambda}$ is not consistent.  Let's give one more example.  Consider the estimator\n\n$$\n  \\hat{\\mu}_c := \\bar{Y} + \\frac{c}{n}\n$$\nwhere $c$ is some constant (this is a strange estimate of $\\E[Y]$ where we take $\\bar{Y}$ and add a constant divided by the sample size).  In this case,\n\n$$\n  \\hat{\\mu}_c \\rightarrow \\E[Y] + 0 = \\E[Y]\n$$\n\nwhich implies that it is consistent.  It is interesting to note that \n\n$$\n  \\E[\\hat{\\mu}_c] = \\E[Y] + \\frac{c}{n}\n$$\nwhich implies that it is biased.  This is an example of a biased estimator that is consistent.\n\n:::\n\n\n## Asymptotic Normality\n\nThe next large sample property that we'll talk about is **asymptotic normality**.  This is a hard one to wrap your mind around, but I'll try to explain as clearly as possible.  We'll start by talking about what it is, and then we'll move to why it's useful.\n\nMost of the estimators that we will talk about this semester have the following property\n\n$$\n  \\sqrt{n}\\left( \\hat{\\theta} - \\theta \\right) \\rightarrow N(0,V) \\quad \\textrm{as } n \\rightarrow \\infty\n$$\nIn words, what this says is that we can learn something about the sampling distribution of $\\hat{\\theta}$ as long as we have a large enough sample.  More specifically, if $\\hat{\\theta}$ is asymptotically normal, it means that if we take $\\hat{\\theta}$ subtract the true value of the parameter $\\theta$ (this is often referred to as \"centering\") and multiply by $\\sqrt{n}$, then that object (as long as the sample size is large enough) will *seem like* a draw from a normal distribution with mean 0 and variance $V$.  Since we know lots about normal distributions, we'll be able to exploit this in very useful ways in the next section.\n\nAn equivalent, alternative expression that is sometimes useful is \n\n$$\n  \\frac{\\sqrt{n}\\left( \\hat{\\theta} - \\theta\\right)}{\\sqrt{V}} \\rightarrow N(0,1) \\quad \\textrm{as } n \\rightarrow \\infty\n$$\n\nTo establish asymptotic normality of a particular estimator, the main tool is the **central limit theorem**.  The central limit theorem (sometimes abbreviated CLT) says that\n\n$$\n  \\sqrt{n}\\left( \\frac{1}{n} \\sum_{i=1}^n Y_i - \\E[Y]\\right) \\rightarrow N(0,V) \\quad \\textrm{as } n \\rightarrow \\infty\n$$\nwhere $V = \\Var(Y)$.  \n\nIn words, the CLT says that if you take the difference between $\\bar{Y}$ and $\\E[Y]$ (which, by the LLN converges to 0 as $n \\rightarrow \\infty$) and \"scale it up\" by $\\sqrt{n}$ (which goes to $\\infty$ as $n \\rightarrow \\infty$), then $\\sqrt{n}(\\bar{Y} - \\E[Y])$ will act like a draw from a normal distribution with variance $\\Var(Y)$.\n\nThere are a few things to point out:\n\n- Just to start with, this is not nearly as \"natural\" a result as the LLN.  The LLN basically makes perfect sense.  For me, I know how to prove the CLT (though we are not going to do it in class), but I don't think that I would have ever been able to come up with this on my own.\n\n- Notice that the CLT does not rely on any distributional assumptions.  We do not need to assume that $Y$ follows a normal distribution and it will apply when $Y$ follows any distribution (up to some  relatively minor technical conditions that we will not worry about).\n\n- It is also quite remarkable.  We usually have the sense that as the sample size gets large that things will converge to something (e.g., LLN saying that sample averages converge to population averages) or that they will diverge (i.e., go off to positive or negative infinity themselves).  The CLT provides an intermediate case --- $\\sqrt{n}(\\bar{Y} - \\E[Y])$ is neither converging to a particular value or diverging to infinity.  Instead, it is *converging in distribution* --- meaning: it is settling down to something that looks like a draw from some distribution rather than converging to a particular number.  \n\n- In some sense, you can think of this \"convergence in distribution\" as a \"tie\" between the part $(\\bar{Y}-\\E[Y])$ which, by itself, is converging to 0, and $\\sqrt{n}$ which, by itself, is diverging to infinity.  In particular, notice that\n\\begin{align*}\n  \\Var\\Big( \\sqrt{n} (\\bar{Y} - \\E[Y]) \\Big) &= n \\times \\Var(\\bar{Y}) \\\\\n  &= n \\times \\frac{\\Var(Y)}{n} \\\\\n  &= \\Var(Y)\n\\end{align*}\nwhere this argument just holds by the properties of variance that we have used many times before.  This means that the variance of $\\sqrt{n}(\\bar{Y}-\\E[Y])$ does not go to 0 (which would suggest that the whole term converges to 0) nor does it go to $\\infty$ (which would suggest that the term diverges).  Moreover, if you multiplied $(\\bar{Y}-E[Y])$ instead by something somewhat smaller, say, $n^{1/3}$, then the term $(\\bar{Y}-\\E[Y])$ would \"win\" and the whole expression would converge to 0 (to see this, try calculating $\\Var\\Big(n^{1/3}(\\bar{Y} - \\E[Y]\\Big)$).  On the other hand, if you multiplied by something somewhat larger, say, $n$, then the $n$ part would \"win\" and the whole thing would diverge (to see this, try calculating $\\Var\\Big(n(\\bar{Y}-\\E[Y])\\Big)$).  $\\sqrt{n}$ turns out to be \"just right\" so that there is essentially a \"tie\" and this term neither converges to a particular number nor diverges.  \n\n- A very common question for students is: \"how large does $n$ need to be for the central limit theorem to apply?\"  Unfortunately, there is a not a great answer to this (though some textbooks have sometimes given explicit numbers here).  Here is a basic explanation for why it is hard to give a definite number.  Suppose $Y$ follows a normal distribution, then it will not take many observations for the normal approximation to hold.  On the other hand, if $Y$ were to come from a discrete distribution or just a generally complicated distribution, then it might take many more observations for the normal approximation to hold.\n\nAll that to say, I know that the CLT is hard to understand, but the flip-side of that is that it really is a fascinating result.  We'll see how its useful next.\n\n## Inference / Hypothesis Testing\n\nSW 3.2, 3.3\n\nOften in statistics/econometrics, we have some theory that we would like to test.  Pretty soon, we will be interested in testing a theory like: some economic policy had no effect on some outcome of interest.\n\nIn this section, we'll focus on the relatively simple case of conducting inference on $\\E[Y]$, but very similar arguments will apply when we try to start estimating more complicated things soon.  Because we're just focusing on $\\E[Y]$, the examples in this section may be a somewhat trivial/uninteresting, but I want us to learn some mechanics, and then we'll be able to apply these in more complicated situations.\n\nLet's start with defining some terms.\n\n**Null Hypothesis** This is the hypothesis (or theory) that we want to test.  We'll often write it in the following way\n\n$$\n  H_0 : \\E[Y] = \\mu_0\n$$\nwhere $\\mu_0$ is some actual number (e.g., 0 or 10 or just whatever coincides with the theory you want to test).\n\n**Alternative Hypothesis** This is what is true if $H_0$ is not.  There are other possibilities, but I think the only alternative hypothesis that we will consider this semester is\n\n$$\n  H_1 : \\E[Y] \\neq \\mu_0\n$$\ni.e., that $\\E[Y]$ is not equal to the particular value $\\mu_0$.\n\nThe key conceptual issue is that, even if the null hypothesis is true, because we estimate $\\E[Y]$ with a sample, it will generally be the case that $\\bar{Y} \\neq \\mu_0$.  This is just the nature of trying to estimate things with a sample.\n\nWhat we are going to go for is essentially trying to tell the difference (or at least be able to weigh the evidence) regarding whether the difference between $\\bar{Y}$ and $\\mu_0$ can be fully explained by sampling variation or that the difference is \"too big\" to be explained by sampling variation.  Things will start to get \"mathy\" in this section, but I think it is helpful to just hold this high-level idea in your head as we go along.\n\nNext, let's define the **standard error** of an estimator.  Suppose that we know that our estimator is asymptotically normal so that\n\n$$\n  \\sqrt{n}(\\hat{\\theta} - \\theta) \\rightarrow N(0,V) \\quad \\textrm{as } n \\rightarrow \\infty\n$$\nThen, we define the standard error of $\\hat{\\theta}$ as\n\n$$\n  \\textrm{s.e.}(\\hat{\\theta}) := \\frac{\\sqrt{\\hat{V}}}{\\sqrt{n}}\n$$\nwhich is just the square root of the estimate of the asymptotic variance $V$ divided by the square root of the sample size.  For example, in the case where we are trying to estimate $\\E[Y]$, recall that, by the CLT, $\\sqrt{n}(\\bar{Y} - \\E[Y]) \\rightarrow N(0,V)$ where $V=\\Var(Y)$, so that\n\n$$\n  \\textrm{s.e.}(\\bar{Y}) = \\frac{\\sqrt{\\widehat{\\Var}(Y)}}{\\sqrt{n}}\n$$\nwhere $\\widehat{\\Var}(Y)$ is just an estimate of the variance of $Y$, i.e., just run `var(Y)` in `R`.\n\nOver the next few sections, we are going to consider several different way to conduct inference (i.e., weigh the evidence) about some theory (i.e., the null hypothesis) using the data that we have.  For all of the approaches that we consider below, the key ingredients are going to an estimate of the parameter of interest (e.g., $\\bar{Y}$), the value of $\\mu_0$ coming from the null hypothesis, and the standard error of the estimator.\n\n## t-statistics\n\nA **t-statistic** is given by\n\n$$\n  t = \\frac{\\sqrt{n} (\\bar{Y} - \\mu_0)}{\\sqrt{\\hat{V}}}\n$$\nAlternatively (from the definition of standard error), we can write\n\n$$\n  t = \\frac{(\\bar{Y} - \\mu_0)}{\\textrm{s.e.}(\\bar{Y})}\n$$\nthough I'll tend to use the first expression, just because I think it makes the arguments below slightly more clear.\n\nNotice that $t$ is something that we can calculate with our available data.  $\\sqrt{n}$ is the square root of the sample size, $\\bar{Y}$ is the sample average of $Y$, $\\mu_0$ is a number (that we have picked) coming from the null hypothesis, and $\\hat{V}$ is the sample variance of $Y$ (e.g., computed with `var(Y)` in `R`).\n\nNow, here is the interesting thing about t-statistics.  If the null hypothesis is true, then\n\n$$\n  t = \\frac{\\sqrt{n} (\\bar{Y} - \\E[Y])}{\\sqrt{\\hat{V}}} \\approx \\frac{\\sqrt{n} (\\bar{Y} - \\E[Y])}{\\sqrt{V}}\n$$\n\nwhere we have substituted in $\\E[Y]$ for $\\mu_0$ (due to $H_0$ being true) and then replaced $\\hat{V}$ with $V$ (which holds under the law of large numbers).  This is something that we can apply the CLT to, and, in particular, if $H_0$ holds, then\n$$\n  t \\rightarrow N(0,1)\n$$\nThat is, if $H_0$ is true, then $t$ should look like a draw from a normal distribution.\n\nNow, let's think about what happens when the null hypothesis isn't true.  Then, we can write\n\n$$\n  t = \\frac{\\sqrt{n} (\\bar{Y} - \\mu_0)}{\\sqrt{\\hat{V}}}\n$$\nwhich is just the definition of $t$, but something different will happen here.  In order for $t$ to follow a normal distribution, we need $(\\bar{Y} - \\mu_0)$ to converge to 0.  But $\\bar{Y}$ converges to $\\E[Y]$, and if the null hypothesis does not hold, then $\\E[Y] \\neq \\mu_0$ which implies that $(\\bar{Y} - \\mu_0) \\rightarrow (\\E[Y] - \\mu_0) \\neq 0$ as $n \\rightarrow \\infty$.  It's still the case that $\\sqrt{n} \\rightarrow \\infty$.  Thus, if $H_0$ is not true, then $t$ will diverge (recall: this means that it will either go to positive infinity or negative infinity depending on the sign of $(\\E[Y] - \\mu_0)$).\n\nThis gives us a very good way to start to think about whether or not the data is compatible with our theory.  For example, suppose that you calculate $t$ (using your data and under your null hypothesis) and that it is equal to 1.  1 is not an \"unusual\" looking draw from a standard normal distribution --- this suggests that you at least do not have strong evidence from data against your theory.  Alternatively, suppose that you calculate that $t=-24$.  While its technically possible that you could draw $-24$ from a standard normal distribution --- it is exceedingly unlikely.  We would interpret this as strong evidence against the null hypothesis, and it should probably lead you to \"reject\" the null hypothesis.\n\nWe have talked about some clear cases, but what about the \"close calls\"?  Suppose you calculate that $t=2$.  Under the null hypothesis, there is about a 4.6\\% chance of getting a t-statistic at least this large (in absolute value).  So...if $H_0$ is true, this is a fairly unusual t-statistic, but it is not extremely unusual.  What should you do?\n\nBefore we decide what to do, let's introduce a little more terminology regarding what could go wrong with hypothesis testing.  There are two ways that we could go wrong:\n\n**Type I Error** --- This would be to reject $H_0$ when $H_0$ is true\n\n**Type II Error** --- This would be to fail to reject $H_0$ when $H_0$ is false\n\nClearly, there is a tradeoff here.  If you are really concerned with type I errors, you can be very cautious about rejecting $H_0$.  If you are very concerned about type II errors, you could aggressively reject $H_0$.  The traditional approach to trading these off in statistics is to pre-specify a **significance level** indicating what percentage of the time you are willing to commit a type I error.  Usually the significance level is denoted by $\\alpha$ and the most common choice of $\\alpha$ is 0.05 and other common choices are $\\alpha=0.1$ or $\\alpha=0.01$.  Then, good statistical tests try to make as few type II errors as possible subject to the constraint on the rate of type I errors.\n\nOften, once you have specified a significance level, it comes with a **critical value**.  The critical value is the value of a test statistic for which the test just rejects $H_0$.  \n\nIn practice, this leads to the following decision rule:\n\n- Reject $H_0$ if $|t| > c_{1-\\alpha}$ where $c_{1-\\alpha}$ is the critical value corresponding to the significance level $\\alpha$.\n\n- Fail to reject $H_0$ if $|t| < c_{1-\\alpha}$\n\nIn our case, since $t$ follows a normal distribution under $H_0$, the corresponding critical value (when $\\alpha=0.05$) is 1.96.  In particular, recall what the pdf of a standard normal random variable looks like\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nThe sum of the two blue, shaded areas is 0.05.  In other words, under $H_0$, there is a 5\\% chance that, by chance, $t$ would fall in the shaded areas.  If you want to change the significance level, it would result in a corresponding change in the critical value so that the area in the new shaded region would adjust too.  For example, if you set the significance level to be $\\alpha=0.1$, then you would need to adjust the critical value to be 1.64, and if you set $\\alpha=0.01$, then you would need to adjust the critical value to be 2.58.\n\n## P-values\n\nChoosing a significance level is somewhat arbitrary.  What did we choose 5\\%?  \n\nPerhaps more importantly, we are essentially throwing away a lot of information if we are to reduce the information from standard errors/t-statistics to a binary \"reject\" or \"fail to reject\".  \n\nOne alternative is to report a **p-value**.  A p-value is the probability of observing a t-statistic as \"extreme\" as we did if $H_0$ were true.  \n\nHere is an example of how to calculate a p-value.  Suppose we calculate $t=1.85$.  Then,\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nThen, under $H_0$, the probability of getting a t-statistic \"as extreme\" as 1.85 corresponds to the area of the two shaded regions above.  In other words, we need to to compute\n\n$$\n  \\textrm{p-value} = \\P(Z \\leq -1.85) + \\P(Z \\geq 1.85)\n$$\nwhere $Z \\sim N(0,1)$.  One thing that is helpful to notice here is that, a standard normal random variable is symmetric.  This means that $\\P(Z \\leq -1.85) = \\P(Z \\geq 1.85)$.  We also typically denote the cdf of a standard normal random variable with the symbol $\\Phi$.  Thus,\n\n$$\n  \\textrm{p-value} = 2 \\Phi(-1.85)\n$$\nI don't know what this is off the top of my head, but it is easy to compute from a table or using `R`.  In `R`, you can use the function `pnorm` --- here, the p-value is given by `2*pnorm(-1.85)` which is equal to 0.064.\n\nMore generally, if you calculate a t-statistic, $t$, using your data and under $H_0$, then, \n\n$$\n  \\textrm{p-value} = 2 \\Phi(-|t|)\n$$\n\n## Confidence Interval\n\nAnother idea is to report a $(1-\\alpha)\\%$ (e.g., 95%) confidence interval.\n\nThe interpretation of a confidence interval is a bit subtle.  It is this: if we collected a large number of samples, and computed a confidence interval each time, 95% of these would contain the true value.  This is subtly different than: there is a 95% probability that $\\theta$ (the population parameter of interest) falls within the confidence interval --- this second interpretation doesn't make sense because $\\theta$ is non-random.\n\nA 95% confidence interval is given  by \n\n$$\n  CI_{95\\%} = \\left[\\hat{\\theta} - 1.96 \\ \\textrm{s.e.}(\\hat{\\theta}), \\hat{\\theta} + 1.96 \\  \\textrm{s.e.}(\\hat{\\theta})\\right]\n$$\n\nFor the particular case where we are interested in $\\E[Y]$, this becomes\n\n$$\n  CI_{95\\%} = \\left[ \\bar{Y} - 1.96 \\ \\textrm{s.e.}(\\bar{Y}), \\bar{Y} + 1.96 \\ \\textrm{s.e.}(\\bar{Y}) \\right]\n$$\n\n## Inference in Practice\n\nI have covered the main approaches to inference in this section.  I'd like to make a couple of concluding comments.  First, all of the approaches discussed here (standard errors, t-statistics, p-values, and confidence intervals) are very closely related (in some sense, they are just alternative ways to report the same information).  They all rely heavily on establishing asymptotic normality of the estimate of the parameter of interest --- in fact, this is why we were interested in asymptotic normality in the first place.  My sense is that the most common thing to report (at least in economics) is an estimate of the parameter of interest (e.g., $\\hat{\\theta}$ or $\\bar{Y}$) along with its standard error.  If you know this information, you (or your reader) can easily compute any of the other expressions that we've considered in this section.\n\nAnother important thing to mention is that there is often a distinction between **statistical significance** and **economic significance**.  \n\nIn the next chapter, we'll start to think about the *effect* of one variable on another (e.g., the effect of some economic policy on some outcome of interest).  By far the most common null hypothesis in this case is that \"the effect\" is equal to 0.  However, in economics/social sciences/business applications, there probably aren't too many cases where (i) it would be interesting enough to consider the effect of one variable on another (ii) while simultaneously the effect is literally equal to 0.  Since, all else equal, standard errors get smaller with more observations, as datasets in economics tend to get larger over time, we tend to find more statistically significant effects.  This doesn't mean that effects are getting bigger or more important --- just that we are able to detect smaller and smaller effects if we have enough data.  And most questions in economics involve more than just answering the binary question: does variable $X$ have any effect at all on variable $Y$?  For example, if you are trying to evaluate the effect of some economic policy, it is usually more helpful to think in terms of a cost-benefit analysis --- what are the benefits or the policy relative to the costs and these sorts of comparisons inherently involve thinking about magnitudes of effects.\n\nA more succinct way to say all this is: the effect of one variable on another can be both \"statistically significant\" and \"economically\" small at the same time.  Alternatively, if you do not have much data or the data is very \"noisy\", it may be possible that there are relatively large effects, but that the estimates are not statistically significant (i.e., you are not able to detect them very well with the data that you have).  Therefore, it is important to not become too fixated on statistical significance and to additionally think carefully about the magnitudes of estimates.\n\n\n\n## Coding \n\nIn this section, we'll use the `acs` data to calculate an estimate of average wage/salary income among employed individuals in the United States.  We'll test the null hypothesis that the mean income in the United States is \\$50,000 as well as report the standard error of our estimate of mean income, as well as corresponding p-values, t-statistics, and 95% confidence interval.  Finally, we'll report a table of summary statistics using the `modelsummary` package separately by college graduates relative to non-college graduates.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"data/acs.RData\")\n\n# estimate of mean income\nybar <- mean(acs$incwage)\nybar\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 59263.46\n```\n\n\n:::\n\n```{.r .cell-code}\n# calculate standard error\nV <- var(acs$incwage)\nn <- nrow(acs)\nse <- sqrt(V) / sqrt(n)\nse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 713.8138\n```\n\n\n:::\n\n```{.r .cell-code}\n# calculate t-statistic\nt_stat <- (ybar - 50000) / se\nt_stat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.97742\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis clearly exceeds 1.96 (or any common critical value) which implies that we would reject the null hypothesis that mean income is equal to \\$50,000.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate p-value\np_val <- 2*pnorm(-abs(t_stat))\n```\n:::\n\n\n\n\n\n\nThe p-value is essentially equal to 0.  This is expected given the value of the t-statistic that we calculated earlier.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 95% confidence interval\nci_L <- ybar - 1.96*se\nci_U <- ybar + 1.96*se\npaste0(\"[\",round(ci_L,1),\",\",round(ci_U,1),\"]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"[57864.4,60662.5]\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(modelsummary)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`modelsummary` 2.0.0 now uses `tinytable` as its default table-drawing\n  backend. Learn more at: https://vincentarelbundock.github.io/tinytable/\n\nRevert to `kableExtra` for one session:\n\n  options(modelsummary_factory_default = 'kableExtra')\n  options(modelsummary_factory_latex = 'kableExtra')\n  options(modelsummary_factory_html = 'kableExtra')\n\nSilence this message forever:\n\n  config_modelsummary(startup_message = FALSE)\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\n# create a factor variable for going to college\nacs$col <- ifelse(acs$educ >= 16, \"college\", \"non-college\")\nacs$col <- as.factor(acs$col)\nacs$female <- 1*(acs$sex==2)\nacs$incwage <- acs$incwage/1000\ndatasummary_balance(~ col, data=dplyr::select(acs, incwage, female, age, col),\n                    fmt=2)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<!DOCTYPE html> \n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>tinytable_s1uondduoiejmrzzrba1</title>\n    <style>\n.table td.tinytable_css_kfwsuzcpnj3vl4ebpdz1, .table th.tinytable_css_kfwsuzcpnj3vl4ebpdz1 {    border-bottom: solid 0.1em #d3d8dc; }\n.table td.tinytable_css_uuig3jgxgaqzsz6c4oiu, .table th.tinytable_css_uuig3jgxgaqzsz6c4oiu {    text-align: center; }\n.table td.tinytable_css_7ovh03qftu1lf7xwvkm8, .table th.tinytable_css_7ovh03qftu1lf7xwvkm8 {    border-bottom: solid 0.05em #d3d8dc; }\n.table td.tinytable_css_88a1dwu0c0fioh0daw33, .table th.tinytable_css_88a1dwu0c0fioh0daw33 {    text-align: left; }\n.table td.tinytable_css_kwca7mi502dsntcwpgs2, .table th.tinytable_css_kwca7mi502dsntcwpgs2 {    text-align: right; }\n.table td.tinytable_css_9scfa5til173nlkganel, .table th.tinytable_css_9scfa5til173nlkganel {    text-align: right; }\n.table td.tinytable_css_uwqwkh88vieimfhftulc, .table th.tinytable_css_uwqwkh88vieimfhftulc {    text-align: right; }\n.table td.tinytable_css_mn4rnu5kd0tmg5jt7m86, .table th.tinytable_css_mn4rnu5kd0tmg5jt7m86 {    text-align: right; }\n.table td.tinytable_css_zi7r1osjyrucdvprxw4o, .table th.tinytable_css_zi7r1osjyrucdvprxw4o {    text-align: right; }\n.table td.tinytable_css_cgpjng8vxg13xv91crew, .table th.tinytable_css_cgpjng8vxg13xv91crew {    text-align: right; }\n.table td.tinytable_css_0dhb2fi4lnzyv8x86y4f, .table th.tinytable_css_0dhb2fi4lnzyv8x86y4f {    text-align: center; }\n    </style>\n    <script src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>\n    <script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>\n    <script>\n    MathJax = {\n      tex: {\n        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]\n      },\n      svg: {\n        fontCache: 'global'\n      }\n    };\n    </script>\n  </head>\n\n  <body>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_s1uondduoiejmrzzrba1\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n<tr>\n<th scope=\"col\" align=\"center\" colspan=1> </th>\n<th scope=\"col\" align=\"center\" colspan=2>college (N=3871)</th>\n<th scope=\"col\" align=\"center\" colspan=2>non-college (N=6129)</th>\n<th scope=\"col\" align=\"center\" colspan=1> </th>\n<th scope=\"col\" align=\"center\" colspan=1> </th>\n</tr>\n        \n              <tr>\n                <th scope=\"col\"> </th>\n                <th scope=\"col\">Mean</th>\n                <th scope=\"col\">Std. Dev.</th>\n                <th scope=\"col\">Mean</th>\n                <th scope=\"col\">Std. Dev.</th>\n                <th scope=\"col\">Diff. in Means</th>\n                <th scope=\"col\">Std. Error</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>incwage</td>\n                  <td>89.69</td>\n                  <td>96.15</td>\n                  <td>40.05</td>\n                  <td>39.01</td>\n                  <td>-49.65</td>\n                  <td>1.62</td>\n                </tr>\n                <tr>\n                  <td>female </td>\n                  <td>0.51 </td>\n                  <td>0.50 </td>\n                  <td>0.46 </td>\n                  <td>0.50 </td>\n                  <td>-0.04 </td>\n                  <td>0.01</td>\n                </tr>\n                <tr>\n                  <td>age    </td>\n                  <td>44.38</td>\n                  <td>13.43</td>\n                  <td>42.80</td>\n                  <td>15.71</td>\n                  <td>-1.58 </td>\n                  <td>0.29</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n\n    <script>\n      function styleCell_tinytable_1p2lxn70ongrnw6a64i4(i, j, css_id) {\n        var table = document.getElementById(\"tinytable_s1uondduoiejmrzzrba1\");\n        table.rows[i].cells[j].classList.add(css_id);\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_s1uondduoiejmrzzrba1');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_tinytable_1p2lxn70ongrnw6a64i4(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_s1uondduoiejmrzzrba1\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 0, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 1, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 2, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 3, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 4, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 5, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 6, 'tinytable_css_kfwsuzcpnj3vl4ebpdz1') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 0, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 1, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 2, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 3, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 4, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 5, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 6, 'tinytable_css_uuig3jgxgaqzsz6c4oiu') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 1, 'tinytable_css_7ovh03qftu1lf7xwvkm8') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 2, 'tinytable_css_7ovh03qftu1lf7xwvkm8') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 0, 'tinytable_css_88a1dwu0c0fioh0daw33') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 0, 'tinytable_css_88a1dwu0c0fioh0daw33') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 0, 'tinytable_css_88a1dwu0c0fioh0daw33') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 0, 'tinytable_css_88a1dwu0c0fioh0daw33') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 0, 'tinytable_css_88a1dwu0c0fioh0daw33') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 1, 'tinytable_css_kwca7mi502dsntcwpgs2') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 1, 'tinytable_css_kwca7mi502dsntcwpgs2') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 1, 'tinytable_css_kwca7mi502dsntcwpgs2') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 1, 'tinytable_css_kwca7mi502dsntcwpgs2') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 1, 'tinytable_css_kwca7mi502dsntcwpgs2') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 2, 'tinytable_css_9scfa5til173nlkganel') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 2, 'tinytable_css_9scfa5til173nlkganel') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 2, 'tinytable_css_9scfa5til173nlkganel') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 2, 'tinytable_css_9scfa5til173nlkganel') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 2, 'tinytable_css_9scfa5til173nlkganel') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 3, 'tinytable_css_uwqwkh88vieimfhftulc') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 3, 'tinytable_css_uwqwkh88vieimfhftulc') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 3, 'tinytable_css_uwqwkh88vieimfhftulc') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 3, 'tinytable_css_uwqwkh88vieimfhftulc') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 3, 'tinytable_css_uwqwkh88vieimfhftulc') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 4, 'tinytable_css_mn4rnu5kd0tmg5jt7m86') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 4, 'tinytable_css_mn4rnu5kd0tmg5jt7m86') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 4, 'tinytable_css_mn4rnu5kd0tmg5jt7m86') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 4, 'tinytable_css_mn4rnu5kd0tmg5jt7m86') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 4, 'tinytable_css_mn4rnu5kd0tmg5jt7m86') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 5, 'tinytable_css_zi7r1osjyrucdvprxw4o') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 5, 'tinytable_css_zi7r1osjyrucdvprxw4o') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 5, 'tinytable_css_zi7r1osjyrucdvprxw4o') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 5, 'tinytable_css_zi7r1osjyrucdvprxw4o') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 5, 'tinytable_css_zi7r1osjyrucdvprxw4o') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 6, 'tinytable_css_cgpjng8vxg13xv91crew') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(1, 6, 'tinytable_css_cgpjng8vxg13xv91crew') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(2, 6, 'tinytable_css_cgpjng8vxg13xv91crew') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(3, 6, 'tinytable_css_cgpjng8vxg13xv91crew') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(4, 6, 'tinytable_css_cgpjng8vxg13xv91crew') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 0, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 1, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 2, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 3, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 4, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 5, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\nwindow.addEventListener('load', function () { styleCell_tinytable_1p2lxn70ongrnw6a64i4(0, 6, 'tinytable_css_0dhb2fi4lnzyv8x86y4f') })\n    </script>\n\n  </body>\n\n</html>\n```\n\n:::\n:::\n\n\n\n\n\n\n\n## Lab 3: Monte Carlo Simulations\n\nIn this lab, we will study the theoretical properties of the estimators that we have been discussing in this chapter.\n\n**Monte Carlo simulations** are a useful way to study/understand the properties of an estimation procedure.  The basic idea is that, instead of using real data, we are going to use simulated data where we control the data generating process.  This will be useful for two reasons.  First, we will *know* what **the truth** is and compare results coming from our estimation procedure to the truth.  Second, because we are simulating data, we can actually carry out our thought experiment of repeatedly drawing a sample of some particular size.\n\nFor this lab, we are going to make simulated coin flips.\n\n1. Write a function called `flip` that takes in an argument `p` where `p` stands for the probability of flipping a heads (you can code this as a `1` and `0` for tails) and outputs either `1` or `0`.  Run the code \n\n    ```\n    flip(0.5)\n    ```\n\n    **Hint:** It may be helpful to use the `R` function `sample`.  \n\n2. Write a function called `generate_sample` that takes in the arguments `n` and `p` and generates a sample of `n` coin flips where the probability of flipping heads is `p`.  Run the code\n\n    ```\n    generate_sample(10,0.5)\n    ```\n\n3. Next, over 1000 Monte Carlo simulations (i.e., do the following 1000 times), \n\n    (i) generate a new sample with 10 observations\n    \n    (ii) calculate an estimate of $p$ \n    \n    (**Hint:** you can estimate $p$ by just calculating the average number of heads flipped in a particular simulation)\n    \n    (iii) a t-statistic for the null hypothesis that $p=0.5$\n    \n    (iv) and record whether or not you reject the null hypothesis that $p=0.5$ in that simulation\n    \n  Then, using all 1000 Monte Carlo simulations, report (i) an estimate of the bias of your estimator, (ii) an estimate of the variance of your estimator, (iii) an estimate of the mean squared error of your estimator, (iv) plot a histogram of the t-statistics across iterations, and (v) report the fraction of times that you reject $H_0$.  \n  \n4. Same as #3, but with 50 observations in each simulation.  What differences do you notice?\n\n5. Same as #3, but with 50 observations and test $H_0:p=0.6$.  What differences do you notice?\n\n6. Same as #3, but with 50 observations and test $H_0:p=0.9$.  What differences do you notice?\n\n7. Same as #3, but with 1000 observations and test $H_0:p=0.6$.  What differences do you notice?\n\n8. Same as #3, but now set $p=0.95$ (so that this is an unfair coin that flips heads 95% of the time) and with 10 observations and test $H_0:p=0.95$.  What differences do you notice?\n\n9. Same as #8, but with 50 observations.  What differences do you notice?\n\n10. Same as #8, but with 1000 observations.  What differences do you notice?\n\n**Hint:** Since problems 3-10 ask you to do roughly the same thing over and over, it is probably useful to try to write a function to do all of these but with arguments that allow you to change the number of observations per simulation, the true value of $p$, and the null hypothesis that you are testing.\n\n## Lab 3 Solutions\n\n1. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to flip a coin with probability p\nflip <- function(p) {\n  sample(c(0,1), size=1, prob=(c(1-p,p)))\n}\n\n# test out flip function\nflip(0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n2. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to generate a sample of size n\ngenerate_sample <- function(n,p) {\n  Y <- c()\n  for (i in 1:n) {\n    Y[i] <- flip(p)\n  }\n  Y\n}\n\n# test out generate_sample function\ngenerate_sample(10,0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 1 1 1 1 1 0 0 0 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n3. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# carry out monte carlo simulations\nn <- 10\np <- 0.5\nnsims <- 1000  # need to pick large number of monte carlo simulations\nmc_est <- c()  # vector to hold estimation results\nmc_var <- c()  # vector to hold estimated variance\n\nfor (i in 1:nsims) {\n  Y <- generate_sample(n,p)\n  mc_est[i] <- mean(Y)\n  mc_var[i] <- var(Y)\n}\n\n# compute bias\nbias <- mean(mc_est) - p\nbias\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0064\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute sampling variance\nvar <- var(mc_est)\nvar\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02670575\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute mean squared error\nmse <- bias^2 + var\nmse\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02674671\n```\n\n\n:::\n\n```{.r .cell-code}\nH0 <- p\nt <- sqrt(n)*(mc_est - H0) / sqrt(mc_var)\nggplot(data.frame(t=t), aes(x=t)) +\n  geom_histogram(bins=30) +\n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 3 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nrej <- mean(1*(abs(t) >= 1.96))\nrej\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.124\n```\n\n\n:::\n:::\n\n\n\n\n\n\n4. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# since we are going to do this over and over, let's write a function to do it\nmc_sim <- function(n, p, H0) {\n  mc_est <- c()  # vector to hold estimation results\n  mc_var <- c()  # vector to hold estimated variance\n\n  for (i in 1:nsims) {\n    Y <- generate_sample(n,p)\n    mc_est[i] <- mean(Y)\n    mc_var[i] <- var(Y)\n  }\n\n  # compute bias\n  bias <- mean(mc_est) - p\n\n  # compute sampling variance\n  var <- var(mc_est)\n\n  # compute mean squared error\n  mse <- bias^2 + var\n  \n  t <- sqrt(n)*(mc_est - H0) / sqrt(mc_var)\n  hist_plot <- ggplot(data.frame(t=t), aes(x=t)) +\n    geom_histogram(bins=30) + \n    theme_bw()\n\n  rej <- mean(1*(abs(t) >= 1.96))\n  \n  # print results\n  print(paste0(\"bias: \", round(bias,4)))\n  print(paste0(\"var : \", round(var,4)))\n  print(paste0(\"mse : \", round(mse,4)))\n  print(hist_plot)\n  print(paste0(\"rej : \", round(rej,4)))\n}\nmc_sim(50, 0.5, 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: 0.0015\"\n[1] \"var : 0.0054\"\n[1] \"mse : 0.0054\"\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 0.082\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n5.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(50, 0.5, 0.6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: -0.0019\"\n[1] \"var : 0.0047\"\n[1] \"mse : 0.0047\"\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 0.342\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n6.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(50, 0.5, 0.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: 0.0013\"\n[1] \"var : 0.005\"\n[1] \"mse : 0.005\"\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 1\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n7.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(1000, 0.5, 0.6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: 4e-04\"\n[1] \"var : 2e-04\"\n[1] \"mse : 2e-04\"\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 1\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n8.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(10, 0.95, 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: -0.0055\"\n[1] \"var : 0.0051\"\n[1] \"mse : 0.0051\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 565 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 0.565\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n9.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(50, 0.95, 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: -0.0011\"\n[1] \"var : 9e-04\"\n[1] \"mse : 9e-04\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 60 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 0.065\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n10.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmc_sim(1000, 0.95, 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bias: 1e-04\"\n[1] \"var : 0\"\n[1] \"mse : 0\"\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](03-estimators_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rej : 0.067\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Coding Questions\n\n1. For this question, we'll use the data `Airq`.  The variable `rain` contains the amount of rainfall in the county in a year (in inches).  For this question, we'll be interested in testing whether or not the mean rainfall across counties in California is 25 inches.\n\n    a) Estimate the mean rainfall across counties.\n  \n    b) Calculate the standard error of your estimate of rainfall.\n  \n    c) Calculate a t-statistic for $H_0 : \\E[Y] = 25$ where $Y$ denotes rainfall.  Do you reject $H_0$ at a 5% significance level?  Explain.\n  \n    d) Calculate a p-value for $H_0: \\E[Y] = 25$.  How should you interpret this?\n  \n    e) Calculate a 95% confidence interval for average rainfall.\n  \n    f) Use the `datasummary_balance` function from the `modelsummary` package to report average air quality, value added, rain, population density, and average income, separately by whether or not the county is located in a coastal area.\n    \n## Extra Questions\n\n1. What is the difference between consistency and unbiasedness?\n\n2. Suppose you have an estimator that is unbiased.  Will it necessarily be consistent?  If not, provide an example of an unbiased estimator that is not consistent.\n\n3. Suppose you have an estimator that is consistent.  Will it necessarily be unbiased?  If not, provide an example of a consistent estimator that is not unbiased.\n\n4. The Central Limit Theorem says that, $\\sqrt{n}\\left(\\frac{1}{n} \\sum_{i=1}^n (Y_i - \\E[Y])\\right) \\rightarrow N(0,V)$ as $n \\rightarrow \\infty$ where $V = \\var(Y)$.\n\n    a) What happens to $n \\left(\\frac{1}{n} \\sum_{i=1}^n (Y_i - \\E[Y])\\right)$ as $n \\rightarrow \\infty$?  Explain.\n    \n    b) What happens to $n^{1/3} \\left(\\frac{1}{n} \\sum_{i=1}^n (Y_i - \\E[Y])\\right)$ as $n \\rightarrow \\infty$?  Explain.",
    "supporting": [
      "03-estimators_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}